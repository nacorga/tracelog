[{"filePath":"/Users/nachocortesgarcia/Desktop/code/_personal/tracelog/tracelog-script/src/constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/nachocortesgarcia/Desktop/code/_personal/tracelog/tracelog-script/src/events/click-handler.ts","messages":[{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":39,"column":23,"nodeType":"Literal","messageId":"error","endLine":39,"endColumn":27,"suggestions":[{"messageId":"replace","fix":{"range":[890,894],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/prevent-abbreviations","severity":1,"message":"Please rename the variable `relX`. Suggested names are: `relatedX`, `relationshipX`, `relativeX`. A more descriptive name will do too.","line":63,"column":11,"nodeType":"Identifier","messageId":"suggestion","endLine":63,"endColumn":15},{"ruleId":"unicorn/prevent-abbreviations","severity":1,"message":"Please rename the variable `relY`. Suggested names are: `relatedY`, `relationshipY`, `relativeY`. A more descriptive name will do too.","line":64,"column":11,"nodeType":"Identifier","messageId":"suggestion","endLine":64,"endColumn":15},{"ruleId":"unicorn/prefer-dom-node-text-content","severity":2,"message":"Prefer `.textContent` over `.innerText`.","line":86,"column":40,"nodeType":"Identifier","messageId":"error","endLine":86,"endColumn":49,"suggestions":[{"messageId":"suggestion","fix":{"range":[2414,2423],"text":"textContent"},"data":{},"desc":"Switch to `.textContent`."}]},{"ruleId":"unicorn/prefer-dom-node-text-content","severity":2,"message":"Prefer `.textContent` over `.innerText`.","line":87,"column":42,"nodeType":"Identifier","messageId":"error","endLine":87,"endColumn":51,"suggestions":[{"messageId":"suggestion","fix":{"range":[2480,2489],"text":"textContent"},"data":{},"desc":"Switch to `.textContent`."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { HTML_DATA_ATTR_PREFIX } from '../constants';\nimport { TracelogEventClickData } from '../types';\n\nexport interface ClickCoordinates {\n  x: number;\n  y: number;\n  relX: number;\n  relY: number;\n}\n\nexport interface TrackingElementData {\n  element: HTMLElement;\n  name: string;\n  value?: string;\n}\n\n// Move interactive selectors to class level to avoid recreation\nconst INTERACTIVE_SELECTORS = [\n  'button',\n  'a',\n  'input[type=\"button\"]',\n  'input[type=\"submit\"]',\n  'input[type=\"reset\"]',\n  '[role=\"button\"]',\n  '[onclick]',\n  '[data-testid]',\n  '[tabindex]',\n  '[id]',\n] as const;\n\nexport const ClickHandler = {\n  findTrackingElement(element: HTMLElement): HTMLElement | null {\n    if (element.hasAttribute(`${HTML_DATA_ATTR_PREFIX}-name`)) {\n      return element;\n    }\n\n    const closest = element.closest(`[${HTML_DATA_ATTR_PREFIX}-name]`) as HTMLElement;\n\n    return closest || null;\n  },\n\n  getRelevantClickElement(element: HTMLElement): HTMLElement {\n    if (INTERACTIVE_SELECTORS.some((selector) => element.matches(selector))) {\n      return element;\n    }\n\n    for (const selector of INTERACTIVE_SELECTORS) {\n      const parent = element.closest(selector) as HTMLElement;\n      if (parent) {\n        return parent;\n      }\n    }\n\n    return element;\n  },\n\n  calculateClickCoordinates(event: MouseEvent, element: HTMLElement): ClickCoordinates {\n    const rect = element.getBoundingClientRect();\n    const x = event.clientX;\n    const y = event.clientY;\n\n    // Ensure coordinates are within valid bounds\n    const relX = rect.width > 0 ? Math.max(0, Math.min(1, Number(((x - rect.left) / rect.width).toFixed(3)))) : 0;\n    const relY = rect.height > 0 ? Math.max(0, Math.min(1, Number(((y - rect.top) / rect.height).toFixed(3)))) : 0;\n\n    return { x, y, relX, relY };\n  },\n\n  extractTrackingData(trackingElement: HTMLElement): TrackingElementData {\n    const name = trackingElement.getAttribute(`${HTML_DATA_ATTR_PREFIX}-name`);\n    const value = trackingElement.getAttribute(`${HTML_DATA_ATTR_PREFIX}-value`);\n\n    // Add safety check even though it should always exist\n    if (!name) {\n      throw new Error('Tracking element missing required name attribute');\n    }\n\n    return {\n      element: trackingElement,\n      name,\n      ...(value && { value }),\n    };\n  },\n\n  getRelevantText(clickedElement: HTMLElement, relevantElement: HTMLElement): string {\n    const clickedText = clickedElement.innerText?.trim() || '';\n    const relevantText = relevantElement.innerText?.trim() || '';\n\n    // If clicked element has text and relevant doesn't, use clicked text\n    if (clickedText && !relevantText) {\n      return clickedText;\n    }\n\n    // If clicked text is more specific (contained within relevant text), use clicked text\n    if (clickedText && relevantText && clickedText !== relevantText && relevantText.includes(clickedText)) {\n      return clickedText;\n    }\n\n    // Default to relevant element text\n    return relevantText;\n  },\n\n  extractElementAttributes(element: HTMLElement): Record<string, string> {\n    // element.attributes always exists for HTML elements, but check length for early return\n    if (element.attributes.length === 0) {\n      return {};\n    }\n\n    // Only extract common attributes to avoid performance issues\n    const commonAttributes = ['id', 'class', 'data-testid', 'aria-label', 'title', 'href', 'type', 'name'];\n    const result: Record<string, string> = {};\n\n    for (const attributeName of commonAttributes) {\n      const value = element.getAttribute(attributeName);\n      if (value) {\n        result[attributeName] = value;\n      }\n    }\n\n    return result;\n  },\n\n  generateClickData(\n    clickedElement: HTMLElement,\n    relevantElement: HTMLElement,\n    coordinates: ClickCoordinates,\n  ): TracelogEventClickData {\n    const { x, y, relX, relY } = coordinates;\n    const text = this.getRelevantText(clickedElement, relevantElement);\n    const attributes = this.extractElementAttributes(relevantElement);\n\n    const href = relevantElement.getAttribute('href');\n    const title = relevantElement.getAttribute('title');\n    const alt = relevantElement.getAttribute('alt');\n    const role = relevantElement.getAttribute('role');\n    const ariaLabel = relevantElement.getAttribute('aria-label');\n\n    return {\n      x,\n      y,\n      relativeX: relX,\n      relativeY: relY,\n      elementTag: relevantElement.tagName.toLowerCase(),\n      ...(relevantElement.id && { elementId: relevantElement.id }),\n      ...(relevantElement.className && { elementClass: relevantElement.className }),\n      ...(text && { elementText: text }),\n      ...(href && { elementHref: href }),\n      ...(title && { elementTitle: title }),\n      ...(alt && { elementAlt: alt }),\n      ...(role && { elementRole: role }),\n      ...(ariaLabel && { elementAriaLabel: ariaLabel }),\n      ...(Object.keys(attributes).length > 0 && { elementDataAttributes: attributes }),\n    };\n  },\n\n  createCustomEventData(trackingData: TrackingElementData): { name: string; value?: string } {\n    return {\n      name: trackingData.name,\n      ...(trackingData.value && { value: trackingData.value }),\n    };\n  },\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/nachocortesgarcia/Desktop/code/_personal/tracelog/tracelog-script/src/events/inactivity-handler.ts","messages":[{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":14,"column":67,"nodeType":"Literal","messageId":"error","endLine":14,"endColumn":71,"suggestions":[{"messageId":"replace","fix":{"range":[384,388],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":58,"column":45,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":58,"endColumn":47,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[1554,1556],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":113,"column":30,"nodeType":"Literal","messageId":"error","endLine":113,"endColumn":34,"suggestions":[{"messageId":"replace","fix":{"range":[2866,2870],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export interface InactivityConfig {\n  timeout: number; // Timeout in milliseconds\n  events?: string[]; // Events to track for activity\n}\n\nexport interface InactivityData {\n  isInactive: boolean;\n  lastActivityTime: number;\n  inactiveDuration?: number;\n}\n\nexport class InactivityHandler {\n  private isInactive = false;\n  private inactivityTimer: ReturnType<typeof setTimeout> | null = null;\n  private lastActivityTime: number = Date.now();\n  private readonly defaultEvents = ['mousemove', 'keydown', 'scroll', 'click', 'touchstart', 'touchmove'];\n  private readonly eventListeners: Map<string, EventListener> = new Map();\n  private eventsToTrack: string[] = [];\n\n  constructor(\n    private readonly config: InactivityConfig,\n    private readonly onInactivityChange: (data: InactivityData) => void,\n  ) {}\n\n  init(): void {\n    this.setupActivityListeners();\n    this.resetInactivityTimer();\n  }\n\n  getInactivityState(): InactivityData {\n    return {\n      isInactive: this.isInactive,\n      lastActivityTime: this.lastActivityTime,\n      ...(this.isInactive && {\n        inactiveDuration: Date.now() - this.lastActivityTime,\n      }),\n    };\n  }\n\n  forceInactive(): void {\n    this.setInactiveState(true);\n  }\n\n  forceActive(): void {\n    this.setInactiveState(false);\n    this.resetInactivityTimer();\n  }\n\n  updateTimeout(newTimeout: number): void {\n    this.config.timeout = newTimeout;\n\n    if (this.inactivityTimer) {\n      this.resetInactivityTimer();\n    }\n  }\n\n  private setupActivityListeners(): void {\n    this.eventsToTrack = this.config.events || this.defaultEvents;\n\n    const handleActivity = this.handleUserActivity.bind(this);\n\n    for (const event of this.eventsToTrack) {\n      this.eventListeners.set(event, handleActivity);\n      window.addEventListener(event, handleActivity, {\n        passive: true,\n        capture: true,\n      });\n    }\n  }\n\n  private handleUserActivity(): void {\n    this.lastActivityTime = Date.now();\n\n    if (this.isInactive) {\n      this.setInactiveState(false);\n    }\n\n    this.resetInactivityTimer();\n  }\n\n  private resetInactivityTimer(): void {\n    if (this.inactivityTimer) {\n      clearTimeout(this.inactivityTimer);\n    }\n\n    this.inactivityTimer = setTimeout(() => {\n      this.setInactiveState(true);\n    }, this.config.timeout);\n  }\n\n  private setInactiveState(inactive: boolean): void {\n    if (this.isInactive === inactive) {\n      return; // No change\n    }\n\n    this.isInactive = inactive;\n\n    const inactivityData: InactivityData = {\n      isInactive: inactive,\n      lastActivityTime: this.lastActivityTime,\n      ...(inactive && {\n        inactiveDuration: Date.now() - this.lastActivityTime,\n      }),\n    };\n\n    this.onInactivityChange(inactivityData);\n  }\n\n  cleanup(): void {\n    // Clear timer\n    if (this.inactivityTimer) {\n      clearTimeout(this.inactivityTimer);\n      this.inactivityTimer = null;\n    }\n\n    // Remove all event listeners\n    for (const [event, listener] of this.eventListeners.entries()) {\n      window.removeEventListener(event, listener, {\n        capture: true,\n      });\n    }\n\n    // Clear collections\n    this.eventListeners.clear();\n    this.eventsToTrack = [];\n  }\n\n  // Static utility methods for common inactivity scenarios\n  static createStandardConfig(timeoutMinutes = 5): InactivityConfig {\n    return {\n      timeout: timeoutMinutes * 60 * 1000, // Convert minutes to milliseconds\n      events: ['mousemove', 'keydown', 'scroll', 'click', 'touchstart', 'touchmove'],\n    };\n  }\n\n  static createMobileOptimizedConfig(timeoutMinutes = 3): InactivityConfig {\n    return {\n      timeout: timeoutMinutes * 60 * 1000,\n      events: ['touchstart', 'touchmove', 'touchend', 'scroll', 'click', 'keydown'],\n    };\n  }\n\n  static createMinimalConfig(timeoutMinutes = 10): InactivityConfig {\n    return {\n      timeout: timeoutMinutes * 60 * 1000,\n      events: ['click', 'keydown'], // Only essential events\n    };\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/nachocortesgarcia/Desktop/code/_personal/tracelog/tracelog-script/src/events/pageview-handler.ts","messages":[{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":18,"column":57,"nodeType":"Literal","messageId":"error","endLine":18,"endColumn":61,"suggestions":[{"messageId":"replace","fix":{"range":[409,413],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":64,"column":41,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":64,"endColumn":43},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":70,"column":44,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":70,"endColumn":46},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":109,"column":68,"nodeType":"Literal","messageId":"error","endLine":109,"endColumn":72,"suggestions":[{"messageId":"replace","fix":{"range":[2839,2843],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/consistent-function-scoping","severity":2,"message":"Move arrow function 'isRegExp' to the outer scope.","line":119,"column":56,"nodeType":"ArrowFunctionExpression","messageId":"consistent-function-scoping","endLine":119,"endColumn":58},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":122,"column":43,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":122,"endColumn":45},{"ruleId":"unicorn/consistent-function-scoping","severity":2,"message":"Move arrow function 'escapeRegex' to the outer scope.","line":122,"column":43,"nodeType":"ArrowFunctionExpression","messageId":"consistent-function-scoping","endLine":122,"endColumn":45},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":123,"column":47,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":123,"endColumn":49},{"ruleId":"unicorn/no-array-callback-reference","severity":2,"message":"Do not pass function `escapeRegex` directly to `.map(…)`.","line":123,"column":90,"nodeType":"Identifier","messageId":"error-with-name","endLine":123,"endColumn":101,"suggestions":[{"messageId":"replace-with-name","data":{"name":"escapeRegex","method":"map","parameters":"element"},"fix":{"range":[3402,3413],"text":"(element) => escapeRegex(element)"},"desc":"Replace function `escapeRegex` with `… => escapeRegex(element)`."},{"messageId":"replace-with-name","data":{"name":"escapeRegex","method":"map","parameters":"element, index"},"fix":{"range":[3402,3413],"text":"(element, index) => escapeRegex(element, index)"},"desc":"Replace function `escapeRegex` with `… => escapeRegex(element, index)`."},{"messageId":"replace-with-name","data":{"name":"escapeRegex","method":"map","parameters":"element, index, array"},"fix":{"range":[3402,3413],"text":"(element, index, array) => escapeRegex(element, index, array)"},"desc":"Replace function `escapeRegex` with `… => escapeRegex(element, index, array)`."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { UTM_PARAMS } from '../constants';\nimport { TracelogEventUtm } from '../types';\n\nexport interface NavigationData {\n  fromUrl: string;\n  toUrl: string;\n  referrer?: string;\n  utm?: TracelogEventUtm;\n}\n\nexport interface PageViewConfig {\n  trackReferrer?: boolean;\n  trackUTM?: boolean;\n}\n\nexport class PageViewHandler {\n  private currentUrl = '';\n  private readonly utmParams: TracelogEventUtm | null = null;\n\n  constructor(\n    private readonly config: PageViewConfig,\n    private readonly onNavigationEvent: (data: NavigationData) => void,\n  ) {\n    this.currentUrl = window.location.href;\n    if (this.config.trackUTM !== false) {\n      this.utmParams = this.extractUTMParameters();\n    }\n  }\n\n  init(): void {\n    this.setupNavigationTracking();\n  }\n\n  getCurrentUrl(): string {\n    return this.currentUrl;\n  }\n\n  getUTMParams(): TracelogEventUtm | null {\n    return this.utmParams;\n  }\n\n  handleInitialPageView(): NavigationData {\n    const data: NavigationData = {\n      fromUrl: '',\n      toUrl: this.currentUrl,\n    };\n\n    if (this.config.trackReferrer !== false) {\n      data.referrer = document.referrer || 'Direct';\n    }\n\n    if (this.utmParams) {\n      data.utm = this.utmParams;\n    }\n\n    return data;\n  }\n\n  private setupNavigationTracking(): void {\n    // Override history methods to track SPA navigation\n    const originalPushState = history.pushState;\n    const originalReplaceState = history.replaceState;\n\n    history.pushState = (...arguments_) => {\n      const fromUrl = this.currentUrl;\n      originalPushState.apply(history, arguments_);\n      this.handleNavigation(fromUrl, window.location.href);\n    };\n\n    history.replaceState = (...arguments_) => {\n      const fromUrl = this.currentUrl;\n      originalReplaceState.apply(history, arguments_);\n      this.handleNavigation(fromUrl, window.location.href);\n    };\n\n    // Handle popstate events (back/forward buttons)\n    window.addEventListener('popstate', () => {\n      const fromUrl = this.currentUrl;\n      this.handleNavigation(fromUrl, window.location.href);\n    });\n  }\n\n  private handleNavigation(fromUrl: string, toUrl: string): void {\n    if (fromUrl === toUrl) return;\n\n    this.currentUrl = toUrl;\n\n    const navigationData: NavigationData = {\n      fromUrl,\n      toUrl,\n    };\n\n    this.onNavigationEvent(navigationData);\n  }\n\n  private extractUTMParameters(): TracelogEventUtm | null {\n    const urlParameters = new URLSearchParams(window.location.search);\n    const utmParameters: Partial<Record<keyof TracelogEventUtm, string>> = {};\n\n    for (const parameter of UTM_PARAMS) {\n      const value = urlParameters.get(parameter);\n\n      if (value) {\n        const key = parameter.split('utm_')[1] as keyof TracelogEventUtm;\n        utmParameters[key] = value;\n      }\n    }\n\n    return Object.keys(utmParameters).length > 0 ? utmParameters : null;\n  }\n\n  static isRouteExcluded(url: string, excludedPaths: string[] = []): boolean {\n    if (excludedPaths.length === 0) {\n      return false;\n    }\n\n    const path = new URL(url, window.location.origin).pathname;\n\n    const isRegExp = (value: unknown): value is RegExp =>\n      typeof value === 'object' && value !== null && typeof (value as RegExp).test === 'function';\n\n    const escapeRegex = (string_: string) => string_.replaceAll(/[$()*+.?[\\\\\\]^{|}]/g, '\\\\$&');\n    const wildcardToRegex = (string_: string) => new RegExp('^' + string_.split('*').map(escapeRegex).join('.+') + '$');\n\n    return excludedPaths.some((pattern) => {\n      if (isRegExp(pattern)) {\n        return pattern.test(path);\n      }\n\n      if (pattern.includes('*')) {\n        return wildcardToRegex(pattern).test(path);\n      }\n\n      return pattern === path;\n    });\n  }\n\n  updateUrl(url: string): void {\n    this.currentUrl = url;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/nachocortesgarcia/Desktop/code/_personal/tracelog/tracelog-script/src/events/scroll-handler.ts","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":52,"column":33,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":52,"endColumn":35,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[1414,1416],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":57,"column":29,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":57,"endColumn":31},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":87,"column":37,"nodeType":"Literal","messageId":"error","endLine":87,"endColumn":41,"suggestions":[{"messageId":"replace","fix":{"range":[2438,2442],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":89,"column":37,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":89,"endColumn":39,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[2521,2523],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":91,"column":38,"nodeType":"Literal","messageId":"error","endLine":91,"endColumn":42,"suggestions":[{"messageId":"replace","fix":{"range":[2585,2589],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":98,"column":22,"nodeType":"Literal","messageId":"error","endLine":98,"endColumn":26,"suggestions":[{"messageId":"replace","fix":{"range":[2710,2714],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":100,"column":25,"nodeType":"Literal","messageId":"error","endLine":100,"endColumn":29,"suggestions":[{"messageId":"replace","fix":{"range":[2770,2774],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/consistent-destructuring","severity":2,"message":"Use destructured variables over properties.","line":119,"column":35,"nodeType":"MemberExpression","messageId":"consistentDestructuring","endLine":119,"endColumn":58,"suggestions":[{"messageId":"consistentDestructuringSuggest","data":{"expression":"container.lastScrollPos","property":"lastScrollPos"},"fix":{"range":[3169,3409],"text":", lastScrollPos } = container;\n    const scrollTop = this.getScrollTop(element);\n    const viewportHeight = this.getViewportHeight(element);\n    const scrollHeight = this.getScrollHeight(element);\n\n    const direction = scrollTop > lastScrollPos"},"desc":"Replace `container.lastScrollPos` with destructured property `lastScrollPos`."}]},{"ruleId":"unicorn/consistent-destructuring","severity":2,"message":"Use destructured variables over properties.","line":126,"column":48,"nodeType":"MemberExpression","messageId":"consistentDestructuring","endLine":126,"endColumn":71,"suggestions":[{"messageId":"consistentDestructuringSuggest","data":{"expression":"container.lastScrollPos","property":"lastScrollPos"},"fix":{"range":[3169,3755],"text":", lastScrollPos } = container;\n    const scrollTop = this.getScrollTop(element);\n    const viewportHeight = this.getViewportHeight(element);\n    const scrollHeight = this.getScrollHeight(element);\n\n    const direction = scrollTop > container.lastScrollPos ? ScrollDirection.DOWN : ScrollDirection.UP;\n    const depth =\n      scrollHeight > viewportHeight\n        ? Math.min(100, Math.max(0, Math.floor((scrollTop / (scrollHeight - viewportHeight)) * 100)))\n        : 0;\n\n    // Only update if scroll position changed significantly\n    const positionDelta = Math.abs(scrollTop - lastScrollPos"},"desc":"Replace `container.lastScrollPos` with destructured property `lastScrollPos`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":128,"column":14,"nodeType":"Literal","messageId":"error","endLine":128,"endColumn":18,"suggestions":[{"messageId":"remove","fix":{"range":[3801,3805],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[3801,3805],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { SCROLL_DEBOUNCE_TIME } from '../constants';\nimport { ScrollDirection, TracelogEventScrollData } from '../types';\n\nexport interface ScrollContainer {\n  element: Window | HTMLElement;\n  lastScrollPos: number;\n  debounceTimer: ReturnType<typeof setTimeout> | null;\n  listener: EventListener;\n  animationFrameId: number | null;\n  isThrottled: boolean;\n}\n\nexport interface ScrollConfig {\n  containerSelectors?: string | string[];\n  debounceTime?: number;\n  throttleTime?: number;\n}\n\nexport class ScrollHandler {\n  private containers: ScrollContainer[] = [];\n  private suppressNext = false;\n\n  constructor(\n    private readonly config: ScrollConfig,\n    private readonly onScrollEvent: (data: TracelogEventScrollData) => void,\n  ) {}\n\n  init(): void {\n    const raw = this.config.containerSelectors;\n    const selectors = Array.isArray(raw) ? raw : (typeof raw === 'string' ? [raw] : []);\n\n    const elements: Array<Window | HTMLElement> = selectors\n      .map((sel) => document.querySelector(sel))\n      .filter((element): element is HTMLElement => element instanceof HTMLElement);\n\n    if (elements.length === 0) {\n      elements.push(window);\n    }\n\n    for (const element of elements) {\n      this.setupScrollContainer(element);\n    }\n  }\n\n  suppressNextEvent(): void {\n    this.suppressNext = true;\n\n    setTimeout(\n      () => {\n        this.suppressNext = false;\n      },\n      (this.config.debounceTime || SCROLL_DEBOUNCE_TIME) * 2,\n    );\n  }\n\n  private setupScrollContainer(element: Window | HTMLElement): void {\n    const handleScroll = () => {\n      if (this.suppressNext) {\n        this.suppressNext = false;\n        return;\n      }\n\n      // Cancel pending animation frame\n      if (container.animationFrameId) {\n        cancelAnimationFrame(container.animationFrameId);\n      }\n\n      // Use requestAnimationFrame for better performance\n      container.animationFrameId = requestAnimationFrame(() => {\n        if (container.isThrottled) {\n          return;\n        }\n\n        container.isThrottled = true;\n\n        // Clear existing debounce timer\n        if (container.debounceTimer) {\n          clearTimeout(container.debounceTimer);\n        }\n\n        // Set new debounce timer\n        container.debounceTimer = setTimeout(() => {\n          const scrollData = this.calculateScrollData(container);\n          if (scrollData) {\n            this.onScrollEvent(scrollData);\n          }\n          container.debounceTimer = null;\n          container.isThrottled = false;\n        }, this.config.debounceTime || SCROLL_DEBOUNCE_TIME);\n\n        container.animationFrameId = null;\n      });\n    };\n\n    const container: ScrollContainer = {\n      element,\n      lastScrollPos: 0,\n      debounceTimer: null,\n      listener: handleScroll,\n      animationFrameId: null,\n      isThrottled: false,\n    };\n\n    this.containers.push(container);\n\n    if (element instanceof Window) {\n      window.addEventListener('scroll', handleScroll, { passive: true });\n    } else {\n      element.addEventListener('scroll', handleScroll, { passive: true });\n    }\n  }\n\n  private calculateScrollData(container: ScrollContainer): TracelogEventScrollData | null {\n    const { element } = container;\n    const scrollTop = this.getScrollTop(element);\n    const viewportHeight = this.getViewportHeight(element);\n    const scrollHeight = this.getScrollHeight(element);\n\n    const direction = scrollTop > container.lastScrollPos ? ScrollDirection.DOWN : ScrollDirection.UP;\n    const depth =\n      scrollHeight > viewportHeight\n        ? Math.min(100, Math.max(0, Math.floor((scrollTop / (scrollHeight - viewportHeight)) * 100)))\n        : 0;\n\n    // Only update if scroll position changed significantly\n    const positionDelta = Math.abs(scrollTop - container.lastScrollPos);\n    if (positionDelta < 10) {\n      return null;\n    }\n\n    container.lastScrollPos = scrollTop;\n\n    return { depth, direction };\n  }\n\n  private getScrollTop(element: Window | HTMLElement): number {\n    return element instanceof Window ? window.scrollY : element.scrollTop;\n  }\n\n  private getViewportHeight(element: Window | HTMLElement): number {\n    return element instanceof Window ? window.innerHeight : element.clientHeight;\n  }\n\n  private getScrollHeight(element: Window | HTMLElement): number {\n    return element instanceof Window ? document.documentElement.scrollHeight : element.scrollHeight;\n  }\n\n  cleanup(): void {\n    for (const container of this.containers) {\n      // Clear debounce timer\n      if (container.debounceTimer) {\n        clearTimeout(container.debounceTimer);\n      }\n\n      // Cancel animation frame\n      if (container.animationFrameId) {\n        cancelAnimationFrame(container.animationFrameId);\n      }\n\n      // Remove event listener\n      if (container.element instanceof Window) {\n        window.removeEventListener('scroll', container.listener);\n      } else {\n        container.element.removeEventListener('scroll', container.listener);\n      }\n    }\n\n    this.containers = [];\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/nachocortesgarcia/Desktop/code/_personal/tracelog/tracelog-script/src/events/session-handler.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'LSKey' is defined but never used.","line":1,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":15},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":18,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[381,384],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[381,384],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":19,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[416,419],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[416,419],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":46,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1116,1119],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1116,1119],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":90,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2411,2414],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2411,2414],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":92,"column":39,"nodeType":"Literal","messageId":"error","endLine":92,"endColumn":43,"suggestions":[{"messageId":"remove","fix":{"range":[2462,2469],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[2465,2469],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":98,"column":7,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":100,"endColumn":8,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[2570,2655],"text":"serialized ??= this.memoryFallback.get(key) || null;"},"desc":"Fix to nullish coalescing operator (`??=`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":99,"column":51,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":99,"endColumn":53,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[2639,2641],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":99,"column":54,"nodeType":"Literal","messageId":"error","endLine":99,"endColumn":58,"suggestions":[{"messageId":"replace","fix":{"range":[2642,2646],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":102,"column":52,"nodeType":"Literal","messageId":"error","endLine":102,"endColumn":56,"suggestions":[{"messageId":"replace","fix":{"range":[2708,2712],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":105,"column":14,"nodeType":"Literal","messageId":"error","endLine":105,"endColumn":18,"suggestions":[{"messageId":"remove","fix":{"range":[2816,2820],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[2816,2820],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":149,"column":62,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":149,"endColumn":64,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[4006,4008],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":176,"column":70,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":176,"endColumn":72,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[4670,4672],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":194,"column":45,"nodeType":"Literal","messageId":"error","endLine":194,"endColumn":49,"suggestions":[{"messageId":"replace","fix":{"range":[5162,5166],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":195,"column":46,"nodeType":"Literal","messageId":"error","endLine":195,"endColumn":50,"suggestions":[{"messageId":"replace","fix":{"range":[5213,5217],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":268,"column":26,"nodeType":"Literal","messageId":"error","endLine":268,"endColumn":30,"suggestions":[{"messageId":"replace","fix":{"range":[7178,7182],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":290,"column":32,"nodeType":"Literal","messageId":"error","endLine":290,"endColumn":36,"suggestions":[{"messageId":"replace","fix":{"range":[7720,7724],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":338,"column":24,"nodeType":"Literal","messageId":"error","endLine":338,"endColumn":28,"suggestions":[{"messageId":"replace","fix":{"range":[8954,8958],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { LSKey } from '../constants';\n\nexport interface SessionData {\n  sessionId: string;\n  startTime: number;\n  lastActivity: number;\n  endTrigger?: string;\n}\n\nexport type SessionEndTrigger = 'timeout' | 'manual' | 'page_unload' | 'unexpected_recovery';\n\ninterface HeartbeatData {\n  sessionId: string;\n  timestamp: number;\n}\n\ninterface StorageManager {\n  set(key: string, value: any): boolean;\n  get(key: string): any;\n  remove(key: string): boolean;\n  isAvailable(): boolean;\n  clear(): void;\n  getSize(): number;\n}\n\nclass SafeLocalStorage implements StorageManager {\n  private readonly available: boolean;\n  private readonly memoryFallback: Map<string, string> = new Map();\n\n  constructor() {\n    this.available = this.checkAvailability();\n  }\n\n  private checkAvailability(): boolean {\n    try {\n      const testKey = '__tracelog_test__';\n      window.localStorage.setItem(testKey, 'test');\n      window.localStorage.removeItem(testKey);\n      return true;\n    } catch {\n      console.warn('[TraceLog] localStorage not available, using memory fallback');\n      return false;\n    }\n  }\n\n  set(key: string, value: any): boolean {\n    try {\n      const serialized = JSON.stringify(value);\n\n      if (this.available) {\n        // Check available space before writing\n        const estimatedSize = serialized.length + key.length;\n        if (estimatedSize > 1024 * 1024) {\n          // 1MB limit\n          console.warn('[TraceLog] Data too large for localStorage, using memory fallback');\n          this.memoryFallback.set(key, serialized);\n          return true;\n        }\n\n        window.localStorage.setItem(key, serialized);\n        return true;\n      } else {\n        this.memoryFallback.set(key, serialized);\n        return true;\n      }\n    } catch (error) {\n      // Storage quota exceeded or other error\n      console.warn('[TraceLog] localStorage write failed:', error);\n\n      if (error instanceof DOMException && error.code === 22) {\n        // Storage quota exceeded\n        this.cleanup();\n        try {\n          if (this.available) {\n            window.localStorage.setItem(key, JSON.stringify(value));\n          } else {\n            this.memoryFallback.set(key, JSON.stringify(value));\n          }\n          return true;\n        } catch {\n          this.memoryFallback.set(key, JSON.stringify(value));\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }\n\n  get(key: string): any {\n    try {\n      let serialized: string | null = null;\n\n      if (this.available) {\n        serialized = window.localStorage.getItem(key);\n      }\n\n      if (!serialized) {\n        serialized = this.memoryFallback.get(key) || null;\n      }\n\n      return serialized ? JSON.parse(serialized) : null;\n    } catch (error) {\n      console.warn('[TraceLog] localStorage read failed:', error);\n      return null;\n    }\n  }\n\n  remove(key: string): boolean {\n    try {\n      if (this.available) {\n        window.localStorage.removeItem(key);\n      }\n      this.memoryFallback.delete(key);\n      return true;\n    } catch (error) {\n      console.warn('[TraceLog] localStorage remove failed:', error);\n      return false;\n    }\n  }\n\n  isAvailable(): boolean {\n    return this.available;\n  }\n\n  clear(): void {\n    try {\n      if (this.available) {\n        // Only clear TraceLog keys\n        const keys = Object.keys(window.localStorage);\n        for (const key of keys) {\n          if (key.startsWith('tracelog_') || key.includes('_critical_events') || key.includes('_heartbeat')) {\n            window.localStorage.removeItem(key);\n          }\n        }\n      }\n      this.memoryFallback.clear();\n    } catch (error) {\n      console.warn('[TraceLog] localStorage clear failed:', error);\n    }\n  }\n\n  getSize(): number {\n    try {\n      if (this.available) {\n        let size = 0;\n        for (const key in window.localStorage) {\n          if (key.startsWith('tracelog_') || key.includes('_critical_events') || key.includes('_heartbeat')) {\n            size += window.localStorage.getItem(key)?.length || 0;\n          }\n        }\n        return size;\n      }\n\n      let size = 0;\n      for (const value of this.memoryFallback) {\n        size += value.length;\n      }\n      return size;\n    } catch {\n      return 0;\n    }\n  }\n\n  private cleanup(): void {\n    try {\n      if (!this.available) return;\n\n      // Remove old heartbeat data (older than 24 hours)\n      const cutoffTime = Date.now() - 24 * 60 * 60 * 1000;\n      const keys = Object.keys(window.localStorage);\n\n      for (const key of keys) {\n        if (key.includes('_heartbeat') || key.includes('_critical_events')) {\n          try {\n            const data = JSON.parse(window.localStorage.getItem(key) || '{}');\n            if (data.timestamp && data.timestamp < cutoffTime) {\n              window.localStorage.removeItem(key);\n            }\n          } catch {\n            // Invalid data, remove it\n            window.localStorage.removeItem(key);\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('[TraceLog] localStorage cleanup failed:', error);\n    }\n  }\n}\n\nexport class SessionHandler {\n  private readonly userId: string;\n  private sessionData: SessionData | null = null;\n  private heartbeatInterval: number | null = null;\n  private readonly storage: StorageManager;\n  private readonly HEARTBEAT_INTERVAL = 30_000; // 30 seconds\n\n  constructor(\n    userId: string,\n    private readonly onSessionChange: (data: SessionData) => void,\n    private readonly isQaMode: () => boolean,\n  ) {\n    this.userId = userId;\n    this.storage = new SafeLocalStorage();\n\n    // Perform initial cleanup\n    this.performMaintenanceCleanup();\n  }\n\n  private performMaintenanceCleanup(): void {\n    try {\n      // Remove old data periodically\n      if (Math.random() < 0.1) {\n        // 10% chance on initialization\n        this.storage.clear();\n      }\n\n      // Check storage size and clean if needed\n      const storageSize = this.storage.getSize();\n      if (storageSize > 500 * 1024) {\n        // 500KB limit\n        this.storage.clear();\n        if (this.isQaMode()) {\n          console.log('[TraceLog] Performed storage cleanup due to size limit');\n        }\n      }\n    } catch (error) {\n      console.warn('[TraceLog] Maintenance cleanup failed:', error);\n    }\n  }\n\n  startSession(): SessionData {\n    const sessionData: SessionData = {\n      sessionId: this.generateSessionId(),\n      startTime: Date.now(),\n      lastActivity: Date.now(),\n    };\n\n    this.sessionData = sessionData;\n    this.startHeartbeat();\n    this.onSessionChange(sessionData);\n\n    if (this.isQaMode()) {\n      console.log('[TraceLog] Session started:', sessionData.sessionId);\n    }\n\n    return sessionData;\n  }\n\n  updateActivity(): void {\n    if (this.sessionData) {\n      this.sessionData.lastActivity = Date.now();\n      this.updateHeartbeat();\n    }\n  }\n\n  endSession(trigger: SessionEndTrigger): void {\n    if (this.sessionData) {\n      this.sessionData.endTrigger = trigger;\n      this.stopHeartbeat();\n      this.onSessionChange(this.sessionData);\n\n      if (this.isQaMode()) {\n        console.log('[TraceLog] Session ended:', this.sessionData.sessionId, 'trigger:', trigger);\n      }\n\n      this.sessionData = null;\n    }\n  }\n\n  getCurrentSession(): SessionData | null {\n    return this.sessionData;\n  }\n\n  private generateSessionId(): string {\n    return `${Date.now()}-${Math.random().toString(36).slice(2, 11)}`;\n  }\n\n  private startHeartbeat(): void {\n    this.updateHeartbeat();\n    this.heartbeatInterval = window.setInterval(() => {\n      this.updateHeartbeat();\n    }, this.HEARTBEAT_INTERVAL);\n  }\n\n  private stopHeartbeat(): void {\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n      this.heartbeatInterval = null;\n    }\n    this.clearHeartbeat();\n  }\n\n  private updateHeartbeat(): void {\n    if (this.sessionData) {\n      const heartbeatData: HeartbeatData = {\n        sessionId: this.sessionData.sessionId,\n        timestamp: Date.now(),\n      };\n\n      this.storage.set(`${this.userId}_heartbeat`, heartbeatData);\n    }\n  }\n\n  private clearHeartbeat(): void {\n    this.storage.remove(`${this.userId}_heartbeat`);\n  }\n\n  checkForUnexpectedSessionEnd(): boolean {\n    try {\n      const heartbeatData = this.storage.get(`${this.userId}_heartbeat`);\n\n      if (heartbeatData) {\n        const timeSinceLastHeartbeat = Date.now() - heartbeatData.timestamp;\n\n        // If more than 2 minutes since last heartbeat, session likely ended unexpectedly\n        if (timeSinceLastHeartbeat > 120_000) {\n          this.clearHeartbeat();\n\n          if (this.isQaMode()) {\n            console.log('[TraceLog] Detected unexpected session end from previous session');\n          }\n\n          return true;\n        }\n      }\n    } catch (error) {\n      // Ignore storage errors\n      console.warn('[TraceLog] Error checking for unexpected session end:', error);\n    }\n\n    return false;\n  }\n\n  cleanup(): void {\n    this.stopHeartbeat();\n    this.sessionData = null;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/nachocortesgarcia/Desktop/code/_personal/tracelog/tracelog-script/src/modules/config-manager.ts","messages":[{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":26,"column":7,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":26,"endColumn":20},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":201,"column":14,"nodeType":"Literal","messageId":"error","endLine":201,"endColumn":18,"suggestions":[{"messageId":"remove","fix":{"range":[6832,6836],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[6832,6836],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":212,"column":14,"nodeType":"Literal","messageId":"error","endLine":212,"endColumn":18,"suggestions":[{"messageId":"remove","fix":{"range":[7122,7126],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[7122,7126],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'config' is defined but never used. Allowed unused args must match /^_/u.","line":218,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":218,"endColumn":35},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":286,"column":14,"nodeType":"Literal","messageId":"error","endLine":286,"endColumn":18,"suggestions":[{"messageId":"remove","fix":{"range":[9252,9256],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[9252,9256],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":294,"column":16,"nodeType":"Literal","messageId":"error","endLine":294,"endColumn":20,"suggestions":[{"messageId":"remove","fix":{"range":[9439,9443],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[9439,9443],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":299,"column":14,"nodeType":"Literal","messageId":"error","endLine":299,"endColumn":18,"suggestions":[{"messageId":"remove","fix":{"range":[9505,9509],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[9505,9509],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":305,"column":14,"nodeType":"Literal","messageId":"error","endLine":305,"endColumn":18,"suggestions":[{"messageId":"remove","fix":{"range":[9586,9590],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[9586,9590],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":313,"column":16,"nodeType":"Literal","messageId":"error","endLine":313,"endColumn":20,"suggestions":[{"messageId":"remove","fix":{"range":[9764,9768],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[9764,9768],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":318,"column":14,"nodeType":"Literal","messageId":"error","endLine":318,"endColumn":18,"suggestions":[{"messageId":"remove","fix":{"range":[9827,9831],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[9827,9831],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { TracelogAppConfig, TracelogApiConfig, TracelogConfig } from '../types';\nimport { DEFAULT_TRACKING_API_CONFIG, DEFAULT_TRACKING_APP_CONFIG } from '../constants';\nimport { sanitizeApiConfig } from '../utils/sanitize';\nimport { validateUrl } from '../utils/validate-url';\n\ninterface ErrorReporter {\n  reportError(error: { message: string; context?: string; severity?: 'low' | 'medium' | 'high' }): void;\n}\n\ninterface ConfigLoadResult {\n  config: TracelogConfig;\n  errors: string[];\n  warnings: string[];\n}\n\nexport class ConfigManager {\n  private id = '';\n  private readonly config: TracelogConfig = { ...DEFAULT_TRACKING_API_CONFIG, ...DEFAULT_TRACKING_APP_CONFIG };\n  private readonly errorReporter: ErrorReporter;\n  private lastFetchAttempt = 0;\n  private fetchAttempts = 0;\n  private readonly maxFetchAttempts = 3;\n\n  constructor(private readonly catchError: (error: { message: string; api_key?: string }) => Promise<void>) {\n    this.errorReporter = {\n      reportError: (error) => {\n        this.catchError({\n          message: `[ConfigManager] ${error.message}`,\n          ...(this.id && { api_key: this.id }),\n        }).catch(() => {\n          // Silently handle error reporting failures\n        });\n      },\n    };\n  }\n\n  async loadConfig(id: string, config: TracelogAppConfig): Promise<TracelogConfig> {\n    this.id = id;\n    const result = await this.loadConfigWithValidation(id, config);\n\n    // Log warnings and errors for debugging\n    if (result.warnings.length > 0) {\n      console.warn('[TraceLog] Configuration warnings:', result.warnings);\n    }\n\n    if (result.errors.length > 0) {\n      console.error('[TraceLog] Configuration errors:', result.errors);\n      this.errorReporter.reportError({\n        message: `Configuration errors: ${result.errors.join('; ')}`,\n        severity: 'medium',\n      });\n    }\n\n    return result.config;\n  }\n\n  private async loadConfigWithValidation(id: string, config: TracelogAppConfig): Promise<ConfigLoadResult> {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n    let finalConfig: TracelogConfig = { ...DEFAULT_TRACKING_API_CONFIG, ...config };\n\n    // Validate basic configuration\n    try {\n      const validationResult = this.validateAppConfig(config);\n      errors.push(...validationResult.errors);\n      warnings.push(...validationResult.warnings);\n    } catch (error) {\n      errors.push(`Failed to validate app config: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n\n    // Attempt to fetch remote configuration\n    try {\n      const remoteConfig = await this.fetchConfigWithRetry(config);\n      if (remoteConfig) {\n        finalConfig = { ...finalConfig, ...remoteConfig };\n      } else {\n        warnings.push('Failed to load remote configuration, using defaults');\n      }\n    } catch (error) {\n      errors.push(`Remote config fetch failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n\n    // Final validation\n    try {\n      const finalValidation = this.validateFinalConfig(finalConfig);\n      errors.push(...finalValidation.errors);\n      warnings.push(...finalValidation.warnings);\n\n      // Apply corrections if needed\n      finalConfig = this.applyConfigCorrections(finalConfig);\n    } catch (error) {\n      errors.push(`Final config validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n\n    return {\n      config: finalConfig,\n      errors,\n      warnings,\n    };\n  }\n\n  private validateAppConfig(config: TracelogAppConfig): { errors: string[]; warnings: string[] } {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    // Session timeout validation\n    if (config.sessionTimeout !== undefined) {\n      if (typeof config.sessionTimeout !== 'number') {\n        errors.push('sessionTimeout must be a number');\n      } else if (config.sessionTimeout < 30_000) {\n        errors.push('sessionTimeout must be at least 30 seconds (30000ms)');\n      } else if (config.sessionTimeout > 24 * 60 * 60 * 1000) {\n        warnings.push('sessionTimeout is very long (>24 hours), consider reducing it');\n      }\n    }\n\n    // Global metadata validation\n    if (config.globalMetadata !== undefined) {\n      if (typeof config.globalMetadata !== 'object' || config.globalMetadata === null) {\n        errors.push('globalMetadata must be an object');\n      } else {\n        const metadataSize = JSON.stringify(config.globalMetadata).length;\n        if (metadataSize > 10_240) {\n          // 10KB\n          errors.push('globalMetadata is too large (max 10KB)');\n        }\n\n        if (Object.keys(config.globalMetadata).length > 12) {\n          errors.push('globalMetadata has too many keys (max 12)');\n        }\n      }\n    }\n\n    return { errors, warnings };\n  }\n\n  private validateFinalConfig(config: TracelogConfig): { errors: string[]; warnings: string[] } {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    // Sampling rate validation\n    if (config.samplingRate !== undefined) {\n      if (typeof config.samplingRate !== 'number') {\n        errors.push('samplingRate must be a number');\n      } else if (config.samplingRate < 0 || config.samplingRate > 1) {\n        errors.push('samplingRate must be between 0 and 1');\n      }\n    }\n\n    // Excluded URL paths validation\n    if (config.excludedUrlPaths !== undefined) {\n      if (Array.isArray(config.excludedUrlPaths)) {\n        for (const [index, path] of config.excludedUrlPaths.entries()) {\n          if (typeof path === 'string') {\n            try {\n              new RegExp(path);\n            } catch {\n              errors.push(`excludedUrlPaths[${index}] is not a valid regex pattern`);\n            }\n          } else {\n            errors.push(`excludedUrlPaths[${index}] must be a string`);\n          }\n        }\n      } else {\n        errors.push('excludedUrlPaths must be an array');\n      }\n    }\n\n    return { errors, warnings };\n  }\n\n  private applyConfigCorrections(config: TracelogConfig): TracelogConfig {\n    const correctedConfig = { ...config };\n\n    // Apply default values for invalid configs\n    if (\n      typeof correctedConfig.samplingRate !== 'number' ||\n      correctedConfig.samplingRate < 0 ||\n      correctedConfig.samplingRate > 1\n    ) {\n      correctedConfig.samplingRate = 1;\n    }\n\n    if (!Array.isArray(correctedConfig.excludedUrlPaths)) {\n      correctedConfig.excludedUrlPaths = [];\n    }\n\n    if (typeof correctedConfig.sessionTimeout !== 'number' || correctedConfig.sessionTimeout < 30_000) {\n      correctedConfig.sessionTimeout = 15 * 60 * 1000; // 15 minutes\n    }\n\n    return correctedConfig;\n  }\n\n  private async fetchConfigWithRetry(config: TracelogAppConfig): Promise<TracelogApiConfig | null> {\n    const now = Date.now();\n\n    // Rate limiting\n    if (now - this.lastFetchAttempt < 5000) {\n      // 5 seconds\n      return null;\n    }\n\n    this.lastFetchAttempt = now;\n    this.fetchAttempts++;\n\n    if (this.fetchAttempts > this.maxFetchAttempts) {\n      this.errorReporter.reportError({\n        message: `Max fetch attempts exceeded (${this.maxFetchAttempts})`,\n        severity: 'high',\n      });\n      return null;\n    }\n\n    return this.fetchConfig(config);\n  }\n\n  private async fetchConfig(config: TracelogAppConfig): Promise<TracelogApiConfig | null> {\n    try {\n      const configUrl = this.getConfigUrl();\n\n      if (!configUrl) {\n        throw new Error('Config URL is not valid or not allowed');\n      }\n\n      // Validate URL before making request\n      if (!validateUrl(configUrl, 'tracelog.io')) {\n        throw new Error('Config URL failed security validation');\n      }\n\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), 10_000); // 10 second timeout\n\n      const response = await fetch(configUrl, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n          'User-Agent': 'TraceLog-Client/2.0.4',\n        },\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const json = await response.json();\n      const { statusCode, data } = json;\n\n      if (data === undefined || data === null || typeof statusCode !== 'number') {\n        throw new Error('Config API response missing required properties');\n      }\n\n      if (statusCode !== 200) {\n        throw new Error(`Invalid Config API response status code: ${statusCode}`);\n      }\n\n      const safeData = sanitizeApiConfig(data);\n      const apiConfig = { ...DEFAULT_TRACKING_API_CONFIG, ...(safeData as TracelogApiConfig) };\n\n      // Reset fetch attempts on success\n      this.fetchAttempts = 0;\n\n      return apiConfig;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n\n      this.errorReporter.reportError({\n        message: `Config fetch failed: ${errorMessage}`,\n        context: 'fetchConfig',\n        severity: 'medium',\n      });\n\n      if (error instanceof DOMException && error.name === 'AbortError') {\n        throw new Error('Config fetch timed out');\n      }\n\n      throw error;\n    }\n  }\n\n  private getConfigUrl(): string | null {\n    if (!this.id) {\n      return null;\n    }\n\n    try {\n      const configUrl = `https://${this.id}.tracelog.io/config`;\n\n      // Additional validation\n      if (!validateUrl(configUrl, 'tracelog.io')) {\n        return null;\n      }\n\n      return configUrl;\n    } catch {\n      return null;\n    }\n  }\n\n  getApiUrl(): string | null {\n    if (!this.id) {\n      return null;\n    }\n\n    try {\n      const apiUrl = `https://${this.id}.tracelog.io/api`;\n\n      // Additional validation\n      if (!validateUrl(apiUrl, 'tracelog.io')) {\n        return null;\n      }\n\n      return apiUrl;\n    } catch {\n      return null;\n    }\n  }\n\n  getConfig(): TracelogConfig {\n    return { ...this.config };\n  }\n\n  // Health check methods\n  isHealthy(): boolean {\n    return (\n      this.fetchAttempts < this.maxFetchAttempts && this.config !== null && typeof this.config.samplingRate === 'number'\n    );\n  }\n\n  getHealthStatus(): { healthy: boolean; issues: string[] } {\n    const issues: string[] = [];\n\n    if (this.fetchAttempts >= this.maxFetchAttempts) {\n      issues.push('Max fetch attempts exceeded');\n    }\n\n    if (!this.id) {\n      issues.push('Missing configuration ID');\n    }\n\n    if (!this.config) {\n      issues.push('Configuration not loaded');\n    }\n\n    return {\n      healthy: issues.length === 0,\n      issues,\n    };\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/nachocortesgarcia/Desktop/code/_personal/tracelog/tracelog-script/src/modules/data-sender.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":5,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":5,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[207,210],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[207,210],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":6,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":6,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[242,245],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[242,245],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":43,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1245,1248],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1245,1248],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":93,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":93,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2746,2749],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2746,2749],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":95,"column":39,"nodeType":"Literal","messageId":"error","endLine":95,"endColumn":43,"suggestions":[{"messageId":"remove","fix":{"range":[2797,2804],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[2800,2804],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":101,"column":7,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":103,"endColumn":8,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[2905,2990],"text":"serialized ??= this.memoryFallback.get(key) || null;"},"desc":"Fix to nullish coalescing operator (`??=`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":102,"column":51,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":102,"endColumn":53,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[2974,2976],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":102,"column":54,"nodeType":"Literal","messageId":"error","endLine":102,"endColumn":58,"suggestions":[{"messageId":"replace","fix":{"range":[2977,2981],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":105,"column":52,"nodeType":"Literal","messageId":"error","endLine":105,"endColumn":56,"suggestions":[{"messageId":"replace","fix":{"range":[3043,3047],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":108,"column":14,"nodeType":"Literal","messageId":"error","endLine":108,"endColumn":18,"suggestions":[{"messageId":"remove","fix":{"range":[3146,3150],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[3146,3150],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":180,"column":70,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":180,"endColumn":72,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[5028,5030],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":197,"column":43,"nodeType":"Literal","messageId":"error","endLine":197,"endColumn":47,"suggestions":[{"messageId":"replace","fix":{"range":[5491,5495],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":478,"column":29,"nodeType":"Literal","messageId":"error","endLine":478,"endColumn":33,"suggestions":[{"messageId":"replace","fix":{"range":[13698,13702],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":488,"column":29,"nodeType":"Literal","messageId":"error","endLine":488,"endColumn":33,"suggestions":[{"messageId":"replace","fix":{"range":[13988,13992],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { RETRY_BACKOFF_INITIAL, RETRY_BACKOFF_MAX, LSKey } from '../constants';\nimport { TracelogQueue, TracelogAdminError, EventType } from '../types';\n\ninterface StorageManager {\n  set(key: string, value: any): boolean;\n  get(key: string): any;\n  remove(key: string): boolean;\n  isAvailable(): boolean;\n  clear(): void;\n  getSize(): number;\n}\n\nclass OptimizedStorage implements StorageManager {\n  private readonly available: boolean;\n  private readonly memoryFallback: Map<string, string> = new Map();\n  private readonly compressionEnabled: boolean;\n\n  constructor() {\n    this.available = this.checkAvailability();\n    this.compressionEnabled = this.checkCompressionSupport();\n  }\n\n  private checkAvailability(): boolean {\n    try {\n      const testKey = '__tracelog_storage_test__';\n      window.localStorage.setItem(testKey, 'test');\n      window.localStorage.removeItem(testKey);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  private checkCompressionSupport(): boolean {\n    return typeof window !== 'undefined' && 'CompressionStream' in window;\n  }\n\n  // Compression disabled due to browser compatibility issues\n  private async compress(data: string): Promise<string> {\n    return data;\n  }\n\n  set(key: string, value: any): boolean {\n    try {\n      const serialized = JSON.stringify(value);\n\n      if (this.available) {\n        // Check storage quota\n        const estimatedSize = serialized.length + key.length;\n        if (estimatedSize > 2 * 1024 * 1024) {\n          // 2MB limit\n          console.warn('[TraceLog] Data too large for storage');\n          return false;\n        }\n\n        window.localStorage.setItem(key, serialized);\n        return true;\n      } else {\n        // Use memory fallback with size limit\n        if (this.memoryFallback.size > 100) {\n          // Limit memory usage\n          const firstKey = this.memoryFallback.keys().next().value;\n          if (firstKey) {\n            this.memoryFallback.delete(firstKey);\n          }\n        }\n\n        this.memoryFallback.set(key, serialized);\n        return true;\n      }\n    } catch (error) {\n      if (error instanceof DOMException && error.code === 22) {\n        // Storage quota exceeded\n        this.performEmergencyCleanup();\n        try {\n          if (this.available) {\n            window.localStorage.setItem(key, JSON.stringify(value));\n          } else {\n            this.memoryFallback.set(key, JSON.stringify(value));\n          }\n          return true;\n        } catch (retryError) {\n          console.error('[TraceLog] Storage write failed even after cleanup:', retryError);\n          return false;\n        }\n      }\n\n      console.warn('[TraceLog] Storage write failed:', error);\n      return false;\n    }\n  }\n\n  get(key: string): any {\n    try {\n      let serialized: string | null = null;\n\n      if (this.available) {\n        serialized = window.localStorage.getItem(key);\n      }\n\n      if (!serialized) {\n        serialized = this.memoryFallback.get(key) || null;\n      }\n\n      return serialized ? JSON.parse(serialized) : null;\n    } catch (error) {\n      console.warn('[TraceLog] Storage read failed:', error);\n      return null;\n    }\n  }\n\n  remove(key: string): boolean {\n    try {\n      if (this.available) {\n        window.localStorage.removeItem(key);\n      }\n      this.memoryFallback.delete(key);\n      return true;\n    } catch (error) {\n      console.warn('[TraceLog] Storage remove failed:', error);\n      return false;\n    }\n  }\n\n  isAvailable(): boolean {\n    return this.available;\n  }\n\n  clear(): void {\n    try {\n      if (this.available) {\n        // Only clear TraceLog keys\n        const keys = Object.keys(window.localStorage);\n        for (const key of keys) {\n          if (key.startsWith('tracelog_') || key.includes('_critical_events') || key.includes('_heartbeat')) {\n            window.localStorage.removeItem(key);\n          }\n        }\n      }\n      this.memoryFallback.clear();\n    } catch (error) {\n      console.warn('[TraceLog] Storage clear failed:', error);\n    }\n  }\n\n  getSize(): number {\n    try {\n      if (this.available) {\n        let size = 0;\n        for (const key in window.localStorage) {\n          if (key.startsWith('tracelog_') || key.includes('_critical_events') || key.includes('_heartbeat')) {\n            const item = window.localStorage.getItem(key);\n            size += item ? item.length : 0;\n          }\n        }\n        return size;\n      }\n\n      let size = 0;\n      for (const value of this.memoryFallback) {\n        size += value.length;\n      }\n      return size;\n    } catch {\n      return 0;\n    }\n  }\n\n  private performEmergencyCleanup(): void {\n    try {\n      if (!this.available) return;\n\n      // Remove old data first\n      const cutoffTime = Date.now() - 12 * 60 * 60 * 1000; // 12 hours\n      const keys = Object.keys(window.localStorage);\n\n      for (const key of keys) {\n        if (key.includes('_critical_events') || key.includes('_heartbeat')) {\n          try {\n            const data = JSON.parse(window.localStorage.getItem(key) || '{}');\n            if (data.timestamp && data.timestamp < cutoffTime) {\n              window.localStorage.removeItem(key);\n            }\n          } catch {\n            window.localStorage.removeItem(key);\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('[TraceLog] Emergency cleanup failed:', error);\n    }\n  }\n}\n\nexport class DataSender {\n  private retryDelay: number = RETRY_BACKOFF_INITIAL;\n  private retryTimeoutId: number | null = null;\n  private readonly storage: StorageManager;\n  private lastSendAttempt = 0;\n  private sendAttempts = 0;\n\n  constructor(\n    private readonly apiUrl: string,\n    private readonly isQaMode: () => boolean,\n    private readonly getUserId: () => string,\n  ) {\n    this.storage = new OptimizedStorage();\n  }\n\n  async sendEventsQueue(body: TracelogQueue): Promise<boolean> {\n    const now = Date.now();\n\n    // Rate limiting: prevent too frequent sends\n    if (now - this.lastSendAttempt < 1000) {\n      return false;\n    }\n\n    this.lastSendAttempt = now;\n    this.sendAttempts++;\n\n    const isSendSuccess = await this.collectEventsQueue(body);\n\n    if (isSendSuccess) {\n      this.retryDelay = RETRY_BACKOFF_INITIAL;\n      this.sendAttempts = 0;\n      this.clearRetryTimeout();\n      this.clearPersistedEvents();\n      return true;\n    } else {\n      // If there are critical events and sending failed, try different approach\n      const hasCriticalEvents = body.events.some(\n        (event) => event.type === EventType.SESSION_END || event.type === EventType.SESSION_START,\n      );\n\n      if (hasCriticalEvents) {\n        await this.forceImmediateSend(body);\n      } else {\n        this.scheduleRetry(body);\n      }\n      return false;\n    }\n  }\n\n  async sendEventsSynchronously(body: TracelogQueue): Promise<boolean> {\n    const blob = new Blob([JSON.stringify(body)], { type: 'application/json' });\n\n    // Usar sendBeacon que es la opción más confiable para unload\n    if (navigator.sendBeacon) {\n      const success = navigator.sendBeacon(this.apiUrl, blob);\n\n      if (this.isQaMode()) {\n        console.log(`[TraceLog] Synchronous send via sendBeacon: ${success ? 'SUCCESS' : 'FAILED'}`);\n      }\n\n      if (success) {\n        this.clearPersistedEvents();\n      }\n\n      return success;\n    }\n\n    // Fallback para navegadores sin sendBeacon (muy raro)\n    try {\n      const xhr = new XMLHttpRequest();\n      xhr.open('POST', this.apiUrl, false); // false = synchronous\n      xhr.setRequestHeader('Content-Type', 'application/json');\n      xhr.send(JSON.stringify(body));\n\n      const success = xhr.status >= 200 && xhr.status < 300;\n\n      if (this.isQaMode()) {\n        console.log(`[TraceLog] Synchronous send via XHR: ${success ? 'SUCCESS' : 'FAILED'}`);\n      }\n\n      if (success) {\n        this.clearPersistedEvents();\n      }\n\n      return success;\n    } catch (error) {\n      if (this.isQaMode()) {\n        console.error('[TraceLog] Synchronous send failed:', error);\n      }\n\n      return false;\n    }\n  }\n\n  private async collectEventsQueue(body: TracelogQueue): Promise<boolean> {\n    const blob = new Blob([JSON.stringify(body)], { type: 'application/json' });\n\n    if (navigator.sendBeacon) {\n      const ok = navigator.sendBeacon(this.apiUrl, blob);\n\n      if (ok) {\n        return true;\n      }\n    }\n\n    try {\n      const response = await fetch(this.apiUrl, {\n        method: 'POST',\n        body: blob,\n        keepalive: true,\n        headers: { 'Content-Type': 'application/json' },\n      });\n\n      return response.status >= 200 && response.status < 300;\n    } catch (error) {\n      if (this.isQaMode()) {\n        console.error(\n          'TraceLog error: failed to send events queue',\n          error instanceof Error ? error.message : 'Unknown error',\n        );\n      }\n\n      return false;\n    }\n  }\n\n  private async forceImmediateSend(body: TracelogQueue): Promise<void> {\n    const blob = new Blob([JSON.stringify(body)], { type: 'application/json' });\n\n    // Intentar sendBeacon nuevamente\n    if (navigator.sendBeacon) {\n      const success = navigator.sendBeacon(this.apiUrl, blob);\n      if (success) {\n        this.clearPersistedEvents();\n        return;\n      }\n    }\n\n    // Fallback con fetch síncrono (menos confiable pero mejor que perder el evento)\n    try {\n      const response = await fetch(this.apiUrl, {\n        method: 'POST',\n        body: blob,\n        keepalive: true,\n        headers: { 'Content-Type': 'application/json' },\n      });\n\n      if (response.status >= 200 && response.status < 300) {\n        this.clearPersistedEvents();\n      } else {\n        // Como último recurso, persistir eventos y programar retry\n        this.persistCriticalEvents(body);\n        this.scheduleRetry(body);\n      }\n    } catch (error) {\n      // Último intento: persistir eventos críticos en localStorage\n      this.persistCriticalEvents(body);\n      this.scheduleRetry(body);\n\n      if (this.isQaMode()) {\n        console.error(\n          'TraceLog error: failed to force send critical events, persisting to localStorage',\n          error instanceof Error ? error.message : 'Unknown error',\n        );\n      }\n    }\n  }\n\n  // Persistir eventos críticos en localStorage como respaldo\n  persistCriticalEvents(body: TracelogQueue): void {\n    try {\n      const criticalEvents = body.events.filter(\n        (event) => event.type === EventType.SESSION_END || event.type === EventType.SESSION_START,\n      );\n\n      if (criticalEvents.length > 0) {\n        const persistedData = {\n          userId: body.user_id,\n          sessionId: body.session_id,\n          device: body.device,\n          events: criticalEvents,\n          timestamp: Date.now(),\n          ...(body.global_metadata && { global_metadata: body.global_metadata }),\n        };\n\n        window.localStorage.setItem(`${LSKey.UserId}_critical_events`, JSON.stringify(persistedData));\n\n        if (this.isQaMode()) {\n          console.log('[TraceLog] Critical events persisted to localStorage');\n        }\n      }\n    } catch (error) {\n      if (this.isQaMode()) {\n        console.error('[TraceLog] Failed to persist critical events:', error);\n      }\n    }\n  }\n\n  // Limpiar eventos persistidos después de envío exitoso\n  clearPersistedEvents(): void {\n    try {\n      window.localStorage.removeItem(`${LSKey.UserId}_critical_events`);\n    } catch {\n      // Ignorar errores al limpiar localStorage\n    }\n  }\n\n  // Recuperar y enviar eventos críticos persistidos en inicialización\n  async recoverPersistedEvents(): Promise<void> {\n    try {\n      const persistedData = window.localStorage.getItem(`${LSKey.UserId}_critical_events`);\n\n      if (persistedData) {\n        const data = JSON.parse(persistedData);\n\n        // Solo intentar recovery si los eventos son recientes (menos de 24 horas)\n        const isRecent = Date.now() - data.timestamp < 24 * 60 * 60 * 1000;\n\n        if (isRecent && data.events.length > 0) {\n          const recoveryBody: TracelogQueue = {\n            user_id: data.userId,\n            session_id: data.sessionId,\n            device: data.device,\n            events: data.events,\n            ...(data.global_metadata && { global_metadata: data.global_metadata }),\n          };\n\n          const success = await this.collectEventsQueue(recoveryBody);\n\n          if (success) {\n            this.clearPersistedEvents();\n\n            if (this.isQaMode()) {\n              console.log('[TraceLog] Successfully recovered and sent persisted critical events');\n            }\n          }\n        } else {\n          // Limpiar eventos antiguos\n          this.clearPersistedEvents();\n        }\n      }\n    } catch (error) {\n      if (this.isQaMode()) {\n        console.error('[TraceLog] Failed to recover persisted events:', error);\n      }\n    }\n  }\n\n  async sendError(error: TracelogAdminError): Promise<void> {\n    const blob = new Blob([JSON.stringify(error)], { type: 'application/json' });\n\n    if (navigator.sendBeacon) {\n      const ok = navigator.sendBeacon(`${this.apiUrl}/error`, blob);\n\n      if (ok) {\n        return;\n      }\n    }\n\n    try {\n      await fetch(`${this.apiUrl}/error`, {\n        method: 'POST',\n        body: blob,\n        keepalive: true,\n        headers: { 'Content-Type': 'application/json' },\n      });\n    } catch (error) {\n      if (this.isQaMode()) {\n        console.error('TraceLog error: failed to send error', error instanceof Error ? error.message : 'Unknown error');\n      }\n    }\n\n    if (this.isQaMode()) {\n      console.error(error.message);\n    }\n  }\n\n  private scheduleRetry(body: TracelogQueue): void {\n    if (this.retryTimeoutId !== null) {\n      return;\n    }\n\n    this.retryTimeoutId = window.setTimeout(() => {\n      this.retryTimeoutId = null;\n      this.sendEventsQueue(body);\n    }, this.retryDelay);\n\n    this.retryDelay = Math.min(this.retryDelay * 2, RETRY_BACKOFF_MAX);\n  }\n\n  private clearRetryTimeout(): void {\n    if (this.retryTimeoutId !== null) {\n      clearTimeout(this.retryTimeoutId);\n      this.retryTimeoutId = null;\n    }\n  }\n\n  cleanup(): void {\n    this.clearRetryTimeout();\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/nachocortesgarcia/Desktop/code/_personal/tracelog/tracelog-script/src/modules/event-manager.ts","messages":[{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":17,"column":50,"nodeType":"Literal","messageId":"error","endLine":17,"endColumn":54,"suggestions":[{"messageId":"replace","fix":{"range":[489,493],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":18,"column":45,"nodeType":"Literal","messageId":"error","endLine":18,"endColumn":49,"suggestions":[{"messageId":"replace","fix":{"range":[539,543],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":39,"column":26,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":39,"endColumn":28,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[1505,1507],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":61,"column":39,"nodeType":"Literal","messageId":"error","endLine":61,"endColumn":43,"suggestions":[{"messageId":"remove","fix":{"range":[2140,2147],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[2143,2147],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":120,"column":96,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":120,"endColumn":98,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[4159,4161],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":260,"column":68,"nodeType":"Literal","messageId":"error","endLine":260,"endColumn":72,"suggestions":[{"messageId":"replace","fix":{"range":[8016,8020],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":341,"column":36,"nodeType":"Literal","messageId":"error","endLine":341,"endColumn":40,"suggestions":[{"messageId":"replace","fix":{"range":[10880,10884],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { MAX_EVENTS_QUEUE_LENGTH, EVENT_SENT_INTERVAL, DeviceType, UTM_PARAMS } from '../constants';\nimport {\n  TracelogEvent,\n  TracelogEventHandler,\n  TracelogQueue,\n  EventType,\n  MetadataType,\n  TracelogEventUtm,\n  TracelogConfig,\n  Timestamp,\n} from '../types';\nimport { isEventValid } from '../utils/event-check';\n\nexport class EventManager {\n  private eventsQueue: TracelogEvent[] = [];\n  private hasInitEventsQueueInterval = false;\n  private eventsQueueIntervalId: number | null = null;\n  private lastEvent: TracelogEvent | null = null;\n  private pageUrl = '';\n  private readonly utmParams: TracelogEventUtm | null | undefined;\n\n  constructor(\n    private readonly config: TracelogConfig,\n    private readonly getUserId: () => string,\n    private readonly getSessionId: () => string | undefined,\n    private readonly getDevice: () => DeviceType | undefined,\n    private readonly getGlobalMetadata: () => Record<string, MetadataType> | undefined,\n    private readonly sendEventsQueue: (body: TracelogQueue) => Promise<boolean>,\n    private readonly sendError: (error: { message: string }) => Promise<void>,\n    private readonly isQaMode: () => boolean,\n    private readonly isExcludedUser: () => boolean,\n    private readonly isRouteExcluded: (url: string) => boolean,\n  ) {\n    this.pageUrl = window.location.href;\n    this.utmParams = this.getUTMParameters();\n  }\n\n  handleEvent({ evType, url, fromUrl, scrollData, clickData, customEvent }: TracelogEventHandler): void {\n    const eventUrl = url || this.pageUrl;\n    const isDuplicatedEvent = this.isDuplicatedEvent({ evType, url: eventUrl, scrollData, clickData, customEvent });\n\n    if (isDuplicatedEvent) {\n      if (this.eventsQueue && this.eventsQueue.length > 0) {\n        this.eventsQueue.at(-1).timestamp = Date.now() as Timestamp;\n      }\n\n      return;\n    }\n\n    if (this.isExcludedUser()) {\n      return;\n    }\n\n    const isRouteExcluded = this.isRouteExcluded(eventUrl);\n    const isSessionEvent = [EventType.SESSION_START, EventType.SESSION_END].includes(evType);\n\n    if (isRouteExcluded && !isSessionEvent) {\n      return;\n    }\n\n    let errorMessage: string | null = null;\n\n    if (evType === EventType.SCROLL && !scrollData) {\n      errorMessage = 'scrollData is required for SCROLL event. Event ignored.';\n    }\n\n    if (evType === EventType.CLICK && !clickData) {\n      errorMessage = 'clickData is required for CLICK event. Event ignored.';\n    }\n\n    if (evType === EventType.CUSTOM && !customEvent) {\n      errorMessage = 'customEvent is required for CUSTOM event. Event ignored.';\n    }\n\n    if (errorMessage) {\n      void this.sendError({ message: errorMessage });\n      return;\n    }\n\n    const isFirstEvent = evType === EventType.SESSION_START;\n\n    const payload: TracelogEvent = {\n      type: evType,\n      page_url: eventUrl,\n      timestamp: Date.now() as Timestamp,\n      ...(isFirstEvent && { referrer: document.referrer || 'Direct' }),\n      ...(fromUrl && { from_page_url: fromUrl }),\n      ...(scrollData && { scroll_data: scrollData }),\n      ...(clickData && { click_data: clickData }),\n      ...(customEvent && { custom_event: customEvent }),\n      ...(isFirstEvent && this.utmParams && { utm: this.utmParams }),\n      ...(isRouteExcluded && isSessionEvent && { excluded_route: true }),\n    };\n\n    // Tags functionality disabled for now\n    // if (this.config?.tags?.length) {\n    //   const matchedTags = this.getEventTags(payload, this.getDevice()!);\n    //   if (matchedTags?.length) {\n    //     payload.tags = matchedTags;\n    //   }\n    // }\n\n    this.lastEvent = payload;\n    this.sendEvent(payload);\n  }\n\n  sendCustomEvent(name: string, metadata?: Record<string, MetadataType>): void {\n    const validationResult = isEventValid(name, metadata);\n\n    if (validationResult.valid) {\n      this.handleEvent({\n        evType: EventType.CUSTOM,\n        customEvent: {\n          name,\n          ...(validationResult.sanitizedMetadata && { metadata: validationResult.sanitizedMetadata }),\n        },\n      });\n    } else if (this.isQaMode()) {\n      console.error(\n        `TraceLog error: sendCustomEvent \"${name}\" validation failed (${validationResult.error || 'unknown error'}). Please, review your event data and try again.`,\n      );\n    }\n  }\n\n  updatePageUrl(url: string): void {\n    this.pageUrl = url;\n  }\n\n  getEventsQueue(): TracelogEvent[] {\n    return this.eventsQueue;\n  }\n\n  clearEventsQueue(): void {\n    this.eventsQueue = [];\n  }\n\n  private sendEvent(payload: TracelogEvent): void {\n    if (this.isQaMode()) {\n      console.log(`[TraceLog] ${payload.type} event:`, payload);\n    } else {\n      this.eventsQueue.push(payload);\n\n      if (this.eventsQueue.length > MAX_EVENTS_QUEUE_LENGTH) {\n        this.eventsQueue.shift();\n      }\n\n      if (!this.hasInitEventsQueueInterval) {\n        this.initEventsQueueInterval();\n      }\n\n      if (payload.type === EventType.SESSION_END && this.eventsQueue.length > 0) {\n        this.sendEventsQueueNow();\n      }\n    }\n  }\n\n  private initEventsQueueInterval(): void {\n    this.hasInitEventsQueueInterval = true;\n\n    this.eventsQueueIntervalId = window.setInterval(() => {\n      if (this.eventsQueue.length > 0) {\n        this.sendEventsQueueNow();\n      }\n    }, EVENT_SENT_INTERVAL);\n  }\n\n  private async sendEventsQueueNow(): Promise<void> {\n    if (this.eventsQueue.length === 0) {\n      return;\n    }\n\n    // Use Set for O(1) lookup and more efficient deduplication\n    const uniqueEvents = new Map<string, TracelogEvent>();\n\n    for (const event of this.eventsQueue) {\n      const key = `${event.type}_${event.timestamp}_${event.page_url}`;\n      if (!uniqueEvents.has(key)) {\n        uniqueEvents.set(key, event);\n      }\n    }\n\n    // Convert back to array\n    const deduplicatedEvents = [...uniqueEvents.values()];\n\n    // Sort by timestamp for better server processing\n    deduplicatedEvents.sort((a, b) => a.timestamp - b.timestamp);\n\n    const body: TracelogQueue = {\n      user_id: this.getUserId(),\n      session_id: this.getSessionId()!,\n      device: this.getDevice()!,\n      events: deduplicatedEvents,\n      ...(this.getGlobalMetadata() && { global_metadata: this.getGlobalMetadata() }),\n    };\n\n    const success = await this.sendEventsQueue(body);\n\n    this.eventsQueue = success ? [] : deduplicatedEvents;\n  }\n\n  private isDuplicatedEvent({ evType, url, scrollData, clickData, customEvent }: TracelogEventHandler): boolean {\n    if (!this.lastEvent) {\n      return false;\n    }\n\n    // Quick type check first\n    if (this.lastEvent.type !== evType) {\n      return false;\n    }\n\n    const currentTime = Date.now();\n    const timeDiff = currentTime - this.lastEvent.timestamp;\n    const timeDiffThreshold = 1000; // 1 second\n\n    // Early return if time difference is too large\n    if (timeDiff >= timeDiffThreshold) {\n      return false;\n    }\n\n    // Type-specific duplicate checks\n    switch (evType) {\n      case EventType.PAGE_VIEW: {\n        return this.lastEvent.page_url === url;\n      }\n\n      case EventType.CLICK: {\n        return this.lastEvent.click_data?.x === clickData?.x && this.lastEvent.click_data?.y === clickData?.y;\n      }\n\n      case EventType.SCROLL: {\n        return (\n          this.lastEvent.scroll_data?.depth === scrollData?.depth &&\n          this.lastEvent.scroll_data?.direction === scrollData?.direction\n        );\n      }\n\n      case EventType.CUSTOM: {\n        return this.lastEvent.custom_event?.name === customEvent?.name;\n      }\n\n      default: {\n        return false;\n      }\n    }\n  }\n\n  private getUTMParameters(): TracelogEventUtm | null {\n    const urlParameters = new URLSearchParams(window.location.search);\n    const utmParameters: Partial<Record<keyof TracelogEventUtm, string>> = {};\n\n    for (const parameter of UTM_PARAMS) {\n      const value = urlParameters.get(parameter);\n\n      if (value) {\n        const key = parameter.split('utm_')[1] as keyof TracelogEventUtm;\n        utmParameters[key] = value;\n      }\n    }\n\n    return Object.keys(utmParameters).length > 0 ? utmParameters : null;\n  }\n\n  // Tags functionality disabled for now\n  // private getEventTags(event: TracelogEvent, deviceType: DeviceType): string[] {\n  //   switch (event.type) {\n  //     case EventType.PAGE_VIEW:\n  //       return this.checkEventTypePageView(event, deviceType);\n  //     case EventType.CLICK:\n  //       return this.checkEventTypeClick(event, deviceType);\n  //     default:\n  //       return [];\n  //   }\n  // }\n\n  // private checkEventTypePageView(event: TracelogEvent, deviceType: DeviceType): string[] {\n  //   const tags = this.config?.tags?.filter((tag) => tag.triggerType === EventType.PAGE_VIEW) || [];\n  //   if (!tags.length) {\n  //     return [];\n  //   }\n  //   const matchedTagIds: string[] = [];\n  //   for (const tag of tags) {\n  //     const { logicalOperator, conditions } = tag;\n  //     const results: boolean[] = [];\n  //     for (const condition of conditions) {\n  //       if (condition.type === 'url_matches') {\n  //         results.push(TagManager.matchUrlMatches(condition, event.page_url));\n  //       } else if (condition.type === 'device_type') {\n  //         results.push(TagManager.matchDeviceType(condition, deviceType));\n  //       }\n  //     }\n  //     let isMatch = false;\n  //     if (logicalOperator === 'AND') {\n  //       isMatch = results.every(Boolean);\n  //     } else {\n  //       isMatch = results.some(Boolean);\n  //     }\n  //     if (isMatch) {\n  //       matchedTagIds.push(tag.id);\n  //     }\n  //   }\n  //   return matchedTagIds;\n  // }\n\n  // private checkEventTypeClick(event: TracelogEvent, deviceType: DeviceType): string[] {\n  //   const tags = this.config?.tags?.filter((tag) => tag.triggerType === EventType.CLICK) || [];\n  //   if (!tags.length) {\n  //     return [];\n  //   }\n  //   const matchedTagIds: string[] = [];\n  //   for (const tag of tags) {\n  //     const { logicalOperator, conditions } = tag;\n  //     const results: boolean[] = [];\n  //     for (const condition of conditions) {\n  //       if (!event.click_data) {\n  //         results.push(false);\n  //         continue;\n  //       }\n  //       const clickData = event.click_data;\n  //       if (condition.type === 'element_matches') {\n  //         results.push(TagManager.matchElementSelector(condition, clickData));\n  //       } else if (condition.type === 'device_type') {\n  //         results.push(TagManager.matchDeviceType(condition, deviceType));\n  //       }\n  //     }\n  //     let isMatch = false;\n  //     if (logicalOperator === 'AND') {\n  //       isMatch = results.every(Boolean);\n  //     } else {\n  //       isMatch = results.some(Boolean);\n  //     }\n  //     if (isMatch) {\n  //       matchedTagIds.push(tag.id);\n  //     }\n  //   }\n  //   return matchedTagIds;\n  // }\n\n  cleanup(): void {\n    if (this.eventsQueueIntervalId !== null) {\n      clearInterval(this.eventsQueueIntervalId);\n      this.eventsQueueIntervalId = null;\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/nachocortesgarcia/Desktop/code/_personal/tracelog/tracelog-script/src/modules/id-manager.ts","messages":[{"ruleId":"unicorn/prefer-math-trunc","severity":2,"message":"Use `Math.trunc` instead of `| 0`.","line":50,"column":18,"nodeType":"BinaryExpression","messageId":"error-bitwise","endLine":50,"endColumn":42,"suggestions":[{"messageId":"suggestion-bitwise","fix":{"range":[1126,1150],"text":"Math.trunc(Math.random() * 16)"},"data":{"operator":"|","value":"0"},"desc":"Replace `| 0` with `Math.trunc`."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export const IdManager = {\n  create(): string {\n    if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {\n      return crypto.randomUUID();\n    }\n\n    if (typeof crypto !== 'undefined' && typeof crypto.getRandomValues === 'function') {\n      const buffer = new Uint8Array(16);\n\n      crypto.getRandomValues(buffer);\n\n      buffer[6] = (buffer[6] & 0x0F) | 0x40;\n      buffer[8] = (buffer[8] & 0x3F) | 0x80;\n\n      const hex = Array.from(buffer, (b) => b.toString(16).padStart(2, '0'));\n\n      return [\n        hex.slice(0, 4).join(''),\n        hex.slice(4, 6).join(''),\n        hex.slice(6, 8).join(''),\n        hex.slice(8, 10).join(''),\n        hex.slice(10, 16).join(''),\n      ].join('-');\n    }\n\n    let uuid = '',\n      index = 0;\n\n    while (index < 36) {\n      switch (index) {\n      case 8: \n      case 13: \n      case 18: \n      case 23: {\n        uuid += '-';\n      \n      break;\n      }\n      case 14: {\n        uuid += '4';\n      \n      break;\n      }\n      case 19: {\n        uuid += ((Math.random() * 4) | 8).toString(16);\n      \n      break;\n      }\n      default: {\n        uuid += ((Math.random() * 16) | 0).toString(16);\n      }\n      }\n      index++;\n    }\n\n    return uuid;\n  },\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/nachocortesgarcia/Desktop/code/_personal/tracelog/tracelog-script/src/modules/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/nachocortesgarcia/Desktop/code/_personal/tracelog/tracelog-script/src/modules/session-manager.ts","messages":[{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":10,"column":39,"nodeType":"Literal","messageId":"error","endLine":10,"endColumn":43,"suggestions":[{"messageId":"replace","fix":{"range":[496,500],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":60,"column":31,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":60,"endColumn":33,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[1848,1850],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'isUnloading' is defined but never used. Allowed unused args must match /^_/u.","line":90,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":90,"endColumn":31},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":167,"column":49,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":167,"endColumn":51,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[4348,4350],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":168,"column":94,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":168,"endColumn":96,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[4462,4464],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":174,"column":77,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":174,"endColumn":79,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[4684,4686],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { LSKey, DEFAULT_SAMPLING_RATE, DeviceType } from '../constants';\nimport { IdManager } from './id-manager';\nimport { MetadataType, TracelogConfig, EventType } from '../types';\nimport { getDeviceType } from '../utils/device-detector';\nimport { isValidMetadata } from '../utils/event-check';\nimport { SessionHandler, SessionData, SessionEndTrigger } from '../events/session-handler';\n\nexport class SessionManager {\n  private userId: string | undefined;\n  private tempUserId: string | null = null;\n  private readonly device: DeviceType | undefined;\n  private globalMetadata: Record<string, MetadataType> | undefined;\n  private readonly sessionHandler: SessionHandler;\n\n  constructor(\n    private readonly config: TracelogConfig,\n    private readonly sendSessionEvent: (eventType: EventType, trigger?: string) => void,\n    private readonly isQaMode: () => boolean,\n  ) {\n    this.userId = this.getUserId();\n    this.device = getDeviceType();\n\n    // Initialize session handler\n    this.sessionHandler = new SessionHandler(this.userId, this.handleSessionData.bind(this), this.isQaMode);\n  }\n\n  initialize(): void {\n    this.validateGlobalMetadata();\n  }\n\n  // Getters\n  getUserId(): string {\n    if (this.userId) return this.userId;\n\n    try {\n      const storedId = window.localStorage.getItem(LSKey.UserId);\n\n      if (storedId) {\n        this.userId = storedId;\n        return storedId;\n      }\n\n      const newId = IdManager.create();\n      window.localStorage.setItem(LSKey.UserId, newId);\n      this.userId = newId;\n      return newId;\n    } catch {\n      if (this.tempUserId) {\n        return this.tempUserId;\n      }\n\n      const newId = IdManager.create();\n      this.tempUserId = newId;\n      return newId;\n    }\n  }\n\n  getSessionId(): string {\n    const session = this.sessionHandler.getCurrentSession();\n    return session?.sessionId || '';\n  }\n\n  getDevice(): DeviceType | undefined {\n    return this.device;\n  }\n\n  getGlobalMetadata(): Record<string, MetadataType> | undefined {\n    return this.globalMetadata;\n  }\n\n  // State management\n  isUserInactive(): boolean {\n    const session = this.sessionHandler.getCurrentSession();\n    return !session;\n  }\n\n  hasSessionEnded(): boolean {\n    const session = this.sessionHandler.getCurrentSession();\n    return !session;\n  }\n\n  isSessionEndSent(): boolean {\n    return false; // Simplified for now\n  }\n\n  isPageCurrentlyUnloading(): boolean {\n    return false; // Simplified for now\n  }\n\n  setPageUnloading(isUnloading: boolean): void {\n    // Simplified for now\n  }\n\n  // Session lifecycle management\n  startSession(): void {\n    this.sessionHandler.startSession();\n  }\n\n  endSession(trigger?: string): void {\n    let sessionTrigger: SessionEndTrigger = 'manual';\n\n    switch (trigger) {\n      case 'page_unload': {\n        sessionTrigger = 'page_unload';\n        break;\n      }\n      case 'unexpected_recovery': {\n        sessionTrigger = 'unexpected_recovery';\n        break;\n      }\n      case 'timeout': {\n        sessionTrigger = 'timeout';\n        break;\n      }\n      default: {\n        sessionTrigger = 'manual';\n      }\n    }\n\n    this.sessionHandler.endSession(sessionTrigger);\n  }\n\n  handleInactivity(isInactive: boolean): void {\n    if (!isInactive) {\n      this.sessionHandler.updateActivity();\n    }\n  }\n\n  // Sampling\n  isSampledUser(): boolean {\n    const rate = this.config?.qaMode ? 1 : this.config?.samplingRate || DEFAULT_SAMPLING_RATE;\n\n    if (rate >= 1) {\n      return true;\n    }\n\n    if (rate <= 0) {\n      return false;\n    }\n\n    const userId = this.getUserId();\n    const hex = userId.replaceAll('-', '');\n    const last6 = hex.slice(-6);\n    const hash = Number.parseInt(last6, 16) / 0xFF_FF_FF;\n\n    return hash < rate;\n  }\n\n  checkForUnexpectedSessionEnd(): boolean {\n    return this.sessionHandler.checkForUnexpectedSessionEnd();\n  }\n\n  private handleSessionData(sessionData: SessionData): void {\n    // Determine event type based on session data\n    const eventType = EventType.SESSION_START; // Simplified for now\n\n    // Map trigger to string for backward compatibility\n    let triggerString: string | undefined;\n    if (sessionData.endTrigger) {\n      triggerString = sessionData.endTrigger;\n    }\n\n    this.sendSessionEvent(eventType, triggerString);\n  }\n\n  private validateGlobalMetadata(): void {\n    if (Object.keys(this.config?.globalMetadata || {}).length > 0) {\n      const { valid, error } = isValidMetadata('globalMetadata', this.config!.globalMetadata || {});\n\n      if (valid) {\n        this.globalMetadata = this.config!.globalMetadata;\n      } else if (this.isQaMode()) {\n        console.error(\n          `TraceLog error: globalMetadata object validation failed (${error || 'unknown error'}). Please, review your data and try again.`,\n        );\n      }\n    }\n  }\n\n  // Cleanup\n  cleanup(): void {\n    this.sessionHandler?.cleanup();\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/nachocortesgarcia/Desktop/code/_personal/tracelog/tracelog-script/src/modules/tracking-manager.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[548,551],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[548,551],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":29,"column":43,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":29,"endColumn":45,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[1110,1112],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":44,"column":40,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":44,"endColumn":42}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { TracelogConfig, EventType, TracelogEventScrollData } from '../types';\nimport { ClickHandler } from '../events/click-handler';\nimport { ScrollHandler, ScrollConfig } from '../events/scroll-handler';\nimport { InactivityHandler, InactivityConfig, InactivityData } from '../events/inactivity-handler';\n\nexport class TrackingManager {\n  private readonly scrollHandler: ScrollHandler;\n  private readonly inactivityHandler: InactivityHandler;\n\n  constructor(\n    private readonly config: TracelogConfig,\n    private readonly handleEvent: (event: any) => void,\n    private readonly handleInactivity: (isInactive: boolean) => void,\n  ) {\n    // Initialize scroll handler\n    const scrollConfig: ScrollConfig = {\n      containerSelectors: this.config.scrollContainerSelectors,\n    };\n\n    this.scrollHandler = new ScrollHandler(scrollConfig, (scrollData: TracelogEventScrollData) => {\n      this.handleEvent({\n        evType: EventType.SCROLL,\n        scrollData,\n      });\n    });\n\n    // Initialize inactivity handler\n    const inactivityConfig: InactivityConfig = {\n      timeout: this.config.sessionTimeout || 300_000, // Default 5 minutes\n    };\n\n    this.inactivityHandler = new InactivityHandler(inactivityConfig, this.handleInactivityChange.bind(this));\n  }\n\n  initScrollTracking(): void {\n    this.scrollHandler.init();\n  }\n\n  initInactivityTracking(): void {\n    this.inactivityHandler.init();\n  }\n\n  initClickTracking(): void {\n    const handleClick = (event: Event) => {\n      const mouseEvent = event as MouseEvent;\n      const clickedElement = mouseEvent.target as HTMLElement;\n\n      if (!clickedElement) return;\n\n      const trackingElement = ClickHandler.findTrackingElement(clickedElement);\n      const relevantClickElement = ClickHandler.getRelevantClickElement(clickedElement);\n      const coordinates = ClickHandler.calculateClickCoordinates(mouseEvent, clickedElement);\n\n      // Handle custom tracking attributes\n      if (trackingElement) {\n        const trackingData = ClickHandler.extractTrackingData(trackingElement);\n        const attributeData = ClickHandler.createCustomEventData(trackingData);\n\n        this.handleEvent({\n          evType: EventType.CUSTOM,\n          customEvent: {\n            name: attributeData.name,\n            ...(attributeData.value && { metadata: { value: attributeData.value } }),\n          },\n        });\n      }\n\n      // Handle regular click tracking\n      const clickData = ClickHandler.generateClickData(clickedElement, relevantClickElement, coordinates);\n\n      this.handleEvent({\n        evType: EventType.CLICK,\n        url: window.location.href,\n        clickData,\n      });\n    };\n\n    window.addEventListener('click', handleClick, true);\n  }\n\n  suppressNextScrollEvent(): void {\n    this.scrollHandler.suppressNextEvent();\n  }\n\n  forceInactive(): void {\n    this.inactivityHandler.forceInactive();\n  }\n\n  forceActive(): void {\n    this.inactivityHandler.forceActive();\n  }\n\n  getInactivityState(): InactivityData {\n    return this.inactivityHandler.getInactivityState();\n  }\n\n  updateInactivityTimeout(timeoutMs: number): void {\n    this.inactivityHandler.updateTimeout(timeoutMs);\n  }\n\n  private handleInactivityChange(data: InactivityData): void {\n    this.handleInactivity(data.isInactive);\n  }\n\n  cleanup(): void {\n    this.scrollHandler?.cleanup();\n    this.inactivityHandler?.cleanup();\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/nachocortesgarcia/Desktop/code/_personal/tracelog/tracelog-script/src/modules/url-manager.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":9,"column":99,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":102,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[376,379],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[376,379],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[915,918],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[915,918],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { TracelogConfig } from '../types';\nimport { PageViewHandler, NavigationData, PageViewConfig } from '../events/pageview-handler';\n\nexport class UrlManager {\n  private readonly pageViewHandler: PageViewHandler;\n\n  constructor(\n    private readonly config: TracelogConfig,\n    private readonly sendPageViewEvent: (fromUrl: string, toUrl: string, referrer?: string, utm?: any) => void,\n  ) {\n    const pageViewConfig: PageViewConfig = {\n      trackReferrer: true,\n      trackUTM: true,\n    };\n\n    this.pageViewHandler = new PageViewHandler(pageViewConfig, this.handleNavigation.bind(this));\n  }\n\n  initialize(): void {\n    this.pageViewHandler.init();\n\n    // Send initial page view\n    const initialNavigation = this.pageViewHandler.handleInitialPageView();\n    this.handleNavigation(initialNavigation);\n  }\n\n  getCurrentUrl(): string {\n    return this.pageViewHandler.getCurrentUrl();\n  }\n\n  getUTMParams(): any {\n    return this.pageViewHandler.getUTMParams();\n  }\n\n  updateUrl(url: string): void {\n    this.pageViewHandler.updateUrl(url);\n  }\n\n  isRouteExcluded(url: string): boolean {\n    return PageViewHandler.isRouteExcluded(url, this.config.excludedUrlPaths || []);\n  }\n\n  private handleNavigation(data: NavigationData): void {\n    // Only send page view if not excluded\n    if (!this.isRouteExcluded(data.toUrl)) {\n      this.sendPageViewEvent(data.fromUrl, data.toUrl, data.referrer, data.utm);\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/nachocortesgarcia/Desktop/code/_personal/tracelog/tracelog-script/src/public-api.ts","messages":[{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":8,"column":41,"nodeType":"Literal","messageId":"error","endLine":8,"endColumn":45,"suggestions":[{"messageId":"remove","fix":{"range":[290,297],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[293,297],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Tracking } from './tracking';\nimport type { MetadataType, TracelogAppConfig } from './types';\n\n// Re-export only necessary types for tree-shaking\nexport type { MetadataType, TracelogAppConfig } from './types';\n\n// Singleton instance management\nlet trackingInstance: Tracking | null = null;\n\n/**\n * Initialize tracking with configuration\n * @param id - Tracking ID\n * @param config - Optional configuration\n */\nexport const startTracking = (id: string, config?: TracelogAppConfig): void => {\n  if (typeof window === 'undefined' || typeof document === 'undefined') {\n    return;\n  }\n\n  if (trackingInstance) {\n    return;\n  }\n\n  if (config?.sessionTimeout && config.sessionTimeout < 30_000) {\n    console.warn('[TraceLog] sessionTimeout must be at least 30 seconds');\n    return;\n  }\n\n  try {\n    trackingInstance = new Tracking(id, config);\n  } catch (error) {\n    console.error('[TraceLog] Initialization failed:', error instanceof Error ? error.message : 'Unknown error');\n  }\n};\n\n/**\n * Send custom event\n * @param name - Event name\n * @param metadata - Optional metadata\n */\nexport const sendCustomEvent = (name: string, metadata?: Record<string, MetadataType>): void => {\n  if (!trackingInstance) {\n    console.warn('[TraceLog] Not initialized. Call startTracking first.');\n    return;\n  }\n\n  try {\n    // Handle async operation without blocking\n    trackingInstance.sendCustomEvent(name, metadata).catch((error) => {\n      console.error('[TraceLog] Custom event failed:', error instanceof Error ? error.message : 'Unknown error');\n    });\n  } catch (error) {\n    console.error('[TraceLog] Custom event failed:', error instanceof Error ? error.message : 'Unknown error');\n  }\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/nachocortesgarcia/Desktop/code/_personal/tracelog/tracelog-script/src/tracking.ts","messages":[{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":23,"column":66,"nodeType":"Literal","messageId":"error","endLine":23,"endColumn":70,"suggestions":[{"messageId":"replace","fix":{"range":[937,941],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":38,"column":41,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":38,"endColumn":43,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[1567,1569],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":48,"column":75,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":48,"endColumn":77,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[1941,1943],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":144,"column":24,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":144,"endColumn":26},{"ruleId":"unicorn/consistent-function-scoping","severity":2,"message":"Move arrow function 'cleanup' to the outer scope.","line":144,"column":24,"nodeType":"ArrowFunctionExpression","messageId":"consistent-function-scoping","endLine":144,"endColumn":26},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":151,"column":36,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":151,"endColumn":38},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":156,"column":32,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":156,"endColumn":34},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":161,"column":30,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":161,"endColumn":32},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":166,"column":40,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":166,"endColumn":42},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":196,"column":88,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":196,"endColumn":91,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6798,6801],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6798,6801],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":303,"column":49,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":303,"endColumn":51,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[9678,9680],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":334,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":334,"endColumn":18},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":1,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":407,"column":49,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":407,"endColumn":51,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[12378,12380],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ConfigManager } from './modules/config-manager';\nimport { SessionManager } from './modules/session-manager';\nimport { EventManager } from './modules/event-manager';\nimport { TrackingManager } from './modules/tracking-manager';\nimport { DataSender } from './modules/data-sender';\nimport { UrlManager } from './modules/url-manager';\nimport { TracelogAppConfig, TracelogEventHandler, MetadataType, EventType, TracelogAdminError } from './types';\nimport { DeviceType } from './constants';\n\nenum InitializationState {\n  UNINITIALIZED = 'uninitialized',\n  INITIALIZING = 'initializing',\n  INITIALIZED = 'initialized',\n  FAILED = 'failed',\n}\n\nexport class Tracking {\n  public isInitialized = false;\n  public isExcludedUser = false;\n\n  private cleanupListeners: (() => void)[] = [];\n  private initializationState: InitializationState = InitializationState.UNINITIALIZED;\n  private readonly initializationPromise: Promise<void> | null = null;\n  private configManager!: ConfigManager;\n  private sessionManager!: SessionManager;\n  private eventManager!: EventManager;\n  private trackingManager!: TrackingManager;\n  private dataSender!: DataSender;\n  private urlManager!: UrlManager;\n\n  constructor(id: string, config?: TracelogAppConfig) {\n    this.initializationPromise = this.initializeTracking(id, config);\n  }\n\n  private async initializeTracking(id: string, config?: TracelogAppConfig): Promise<void> {\n    // Prevent multiple initialization attempts\n    if (this.initializationState !== InitializationState.UNINITIALIZED) {\n      return this.initializationPromise || Promise.resolve();\n    }\n\n    this.initializationState = InitializationState.INITIALIZING;\n\n    try {\n      // 1. Initialize ConfigManager\n      this.configManager = new ConfigManager(this.catchError.bind(this));\n\n      // 2. Load configuration (local + remote) - await to prevent race conditions\n      const mergedConfig = await this.configManager.loadConfig(id, config || {});\n\n      // 3. Initialize DataSender\n      const apiUrl = this.configManager.getApiUrl();\n      if (!apiUrl) {\n        throw new Error('Failed to get API URL');\n      }\n\n      this.dataSender = new DataSender(\n        apiUrl,\n        () => mergedConfig.qaMode || false,\n        () => this.sessionManager?.getUserId() || '',\n      );\n\n      // 4. Initialize SessionManager\n      this.sessionManager = new SessionManager(\n        mergedConfig,\n        this.handleSessionEvent.bind(this),\n        () => mergedConfig.qaMode || false,\n      );\n\n      // 5. Initialize EventManager\n      this.eventManager = new EventManager(\n        mergedConfig,\n        () => this.sessionManager.getUserId(),\n        () => this.sessionManager.getSessionId(),\n        () => this.sessionManager.getDevice(),\n        () => this.sessionManager.getGlobalMetadata(),\n        this.dataSender.sendEventsQueue.bind(this.dataSender),\n        this.catchError.bind(this),\n        () => mergedConfig.qaMode || false,\n        () => !this.sessionManager.isSampledUser(),\n        (url: string) => this.urlManager?.isRouteExcluded(url) || false,\n      );\n\n      // 6. Initialize UrlManager\n      this.urlManager = new UrlManager(mergedConfig, this.handlePageViewEvent.bind(this));\n\n      // 7. Initialize TrackingManager\n      this.trackingManager = new TrackingManager(\n        mergedConfig,\n        this.handleTrackingEvent.bind(this),\n        this.handleInactivity.bind(this),\n      );\n\n      // 8. Start initialization sequence - await to prevent race conditions\n      await this.startInitializationSequence();\n\n      // 9. Set flags atomically\n      this.isExcludedUser = !this.sessionManager.isSampledUser();\n      this.isInitialized = true;\n      this.initializationState = InitializationState.INITIALIZED;\n\n      if (this.isQaModeSync()) {\n        console.log('[TraceLog] Initialization completed successfully');\n      }\n    } catch (error) {\n      this.initializationState = InitializationState.FAILED;\n      console.error('[TraceLog] Initialization error:', error);\n      throw error;\n    }\n  }\n\n  private async startInitializationSequence(): Promise<void> {\n    // Execute in sequence to prevent race conditions\n    try {\n      // 1. Recover any persisted events from previous sessions\n      await this.dataSender.recoverPersistedEvents();\n\n      // 2. Check for unexpected session end from previous session\n      const hadUnexpectedEnd = this.sessionManager.checkForUnexpectedSessionEnd();\n      if (hadUnexpectedEnd) {\n        // Send the missed SESSION_END event\n        this.handleSessionEvent(EventType.SESSION_END, 'unexpected_recovery');\n      }\n\n      // 3. Start new session\n      this.sessionManager.startSession();\n\n      // 4. Initialize URL tracking (will send initial PAGE_VIEW)\n      this.urlManager.initialize();\n\n      // 5. Initialize tracking systems\n      this.trackingManager.initScrollTracking();\n      this.trackingManager.initInactivityTracking();\n      this.trackingManager.initClickTracking();\n\n      // 6. Setup cleanup on page unload\n      this.setupCleanupListeners();\n    } catch (error) {\n      console.error('[TraceLog] Initialization sequence failed:', error);\n      throw error;\n    }\n  }\n\n  private setupCleanupListeners(): void {\n    const cleanup = () => {\n      if (this.isInitialized) {\n        this.cleanup();\n      }\n    };\n\n    // Create cleanup function for beforeunload\n    const beforeUnloadCleanup = () => {\n      cleanup();\n    };\n\n    // Create cleanup function for pagehide\n    const pageHideCleanup = () => {\n      cleanup();\n    };\n\n    // Create cleanup function for unload\n    const unloadCleanup = () => {\n      cleanup();\n    };\n\n    // Create cleanup function for visibility change\n    const visibilityChangeCleanup = () => {\n      if (document.visibilityState === 'hidden') {\n        this.forceImmediateSend();\n      }\n    };\n\n    // Add event listeners\n    window.addEventListener('beforeunload', beforeUnloadCleanup);\n    window.addEventListener('pagehide', pageHideCleanup);\n    window.addEventListener('unload', unloadCleanup);\n    document.addEventListener('visibilitychange', visibilityChangeCleanup);\n\n    // Store cleanup functions\n    this.cleanupListeners.push(\n      () => window.removeEventListener('beforeunload', beforeUnloadCleanup),\n      () => window.removeEventListener('pagehide', pageHideCleanup),\n      () => window.removeEventListener('unload', unloadCleanup),\n      () => document.removeEventListener('visibilitychange', visibilityChangeCleanup),\n    );\n  }\n\n  // Event handlers\n  private handleSessionEvent(eventType: EventType, trigger?: string): void {\n    this.eventManager.handleEvent({\n      evType: eventType,\n      url: this.urlManager?.getCurrentUrl(),\n      ...(trigger && { trigger }),\n    });\n  }\n\n  private handlePageViewEvent(fromUrl: string, toUrl: string, referrer?: string, utm?: any): void {\n    this.eventManager.handleEvent({\n      evType: EventType.PAGE_VIEW,\n      url: toUrl,\n      fromUrl,\n      ...(referrer && { referrer }),\n      ...(utm && { utm }),\n    });\n  }\n\n  private handleTrackingEvent(event: TracelogEventHandler): void {\n    this.eventManager.handleEvent(event);\n  }\n\n  // Private sync methods for internal use\n  private isQaModeSync(): boolean {\n    return this.configManager?.getConfig()?.qaMode || false;\n  }\n\n  private async handleInactivity(isInactive: boolean): Promise<void> {\n    if (isInactive) {\n      this.sessionManager.handleInactivity(true);\n    } else {\n      this.sessionManager.handleInactivity(false);\n    }\n  }\n\n  private async catchError(error: { message: string; api_key?: string }): Promise<void> {\n    const adminError: TracelogAdminError = {\n      message: error.message,\n      timestamp: Date.now(),\n      userAgent: typeof navigator === 'undefined' ? 'unknown' : navigator.userAgent,\n      url: typeof window === 'undefined' ? 'unknown' : window.location.href,\n      api_key: error.api_key,\n      severity: 'medium',\n      context: 'tracking',\n    };\n    await this.dataSender.sendError(adminError);\n  }\n\n  // Public API methods with race condition protection\n  async sendCustomEvent(name: string, metadata?: Record<string, MetadataType>): Promise<void> {\n    await this.waitForInitialization();\n\n    if (!this.isInitialized || this.isExcludedUser) {\n      return;\n    }\n\n    this.eventManager.sendCustomEvent(name, metadata);\n  }\n\n  // Session management methods with race condition protection\n  async startSession(): Promise<void> {\n    await this.waitForInitialization();\n\n    if (!this.isInitialized) {\n      return;\n    }\n\n    this.sessionManager.startSession();\n  }\n\n  async endSession(): Promise<void> {\n    await this.waitForInitialization();\n\n    if (!this.isInitialized) {\n      return;\n    }\n\n    this.sessionManager.endSession('manual');\n  }\n\n  // Utility methods with race condition protection\n  async getSessionId(): Promise<string> {\n    await this.waitForInitialization();\n\n    if (!this.isInitialized) {\n      return '';\n    }\n\n    return this.sessionManager?.getSessionId() || '';\n  }\n\n  async getUserId(): Promise<string> {\n    await this.waitForInitialization();\n\n    if (!this.isInitialized) {\n      return '';\n    }\n\n    return this.sessionManager?.getUserId() || '';\n  }\n\n  // Data sending methods with race condition protection\n  async forceImmediateSend(): Promise<void> {\n    await this.waitForInitialization();\n\n    if (!this.isInitialized) {\n      return;\n    }\n\n    // Create final batch with any remaining events\n    const events = this.eventManager.getEventsQueue();\n    if (events.length > 0) {\n      const finalBatch = {\n        user_id: this.sessionManager.getUserId(),\n        session_id: this.sessionManager.getSessionId() || '',\n        device: this.sessionManager.getDevice() || DeviceType.Desktop,\n        events: events,\n        ...(this.sessionManager.getGlobalMetadata() && { global_metadata: this.sessionManager.getGlobalMetadata() }),\n      };\n      await this.dataSender.sendEventsSynchronously(finalBatch);\n      this.eventManager.clearEventsQueue();\n    }\n  }\n\n  // Advanced methods with race condition protection\n  async suppressNextScrollEvent(): Promise<void> {\n    await this.waitForInitialization();\n\n    if (!this.isInitialized) {\n      return;\n    }\n\n    this.trackingManager.suppressNextScrollEvent();\n  }\n\n  async updateUrl(url: string): Promise<void> {\n    await this.waitForInitialization();\n\n    if (!this.isInitialized) {\n      return;\n    }\n\n    this.urlManager.updateUrl(url);\n  }\n\n  // Configuration access with race condition protection\n  async getConfig() {\n    await this.waitForInitialization();\n    return this.configManager?.getConfig();\n  }\n\n  async isQaMode(): Promise<boolean> {\n    await this.waitForInitialization();\n    return this.configManager?.getConfig()?.qaMode || false;\n  }\n\n  // Cleanup\n  cleanup(): void {\n    if (!this.isInitialized) {\n      return;\n    }\n\n    try {\n      // 1. End current session\n      this.sessionManager?.endSession('page_unload');\n\n      // 2. Send any remaining events synchronously\n      this.forceImmediateSendSync();\n\n      // 3. Cleanup tracking systems\n      this.trackingManager?.cleanup();\n\n      // 4. Cleanup session system\n      this.sessionManager?.cleanup();\n\n      // 5. Clear any timers\n      this.eventManager?.cleanup();\n\n      // 6. Clear data sender\n      this.dataSender?.cleanup();\n\n      // 7. Remove all event listeners\n      for (const cleanup of this.cleanupListeners) {\n        try {\n          cleanup();\n        } catch (error) {\n          if (this.isQaModeSync()) {\n            console.error('[TraceLog] Error removing event listener:', error);\n          }\n        }\n      }\n      this.cleanupListeners = [];\n\n      // 8. Reset state\n      this.isInitialized = false;\n      this.isExcludedUser = false;\n\n      if (this.isQaModeSync()) {\n        console.log('[TraceLog] Cleanup completed');\n      }\n    } catch (error) {\n      if (this.isQaModeSync()) {\n        console.error('[TraceLog] Cleanup error:', error);\n      }\n    }\n  }\n\n  // Sync version for cleanup\n  private forceImmediateSendSync(): void {\n    if (!this.isInitialized) {\n      return;\n    }\n\n    // Create final batch with any remaining events\n    const events = this.eventManager.getEventsQueue();\n    if (events.length > 0) {\n      const finalBatch = {\n        user_id: this.sessionManager.getUserId(),\n        session_id: this.sessionManager.getSessionId() || '',\n        device: this.sessionManager.getDevice() || DeviceType.Desktop,\n        events: events,\n        ...(this.sessionManager.getGlobalMetadata() && { global_metadata: this.sessionManager.getGlobalMetadata() }),\n      };\n      this.dataSender.sendEventsSynchronously(finalBatch);\n      this.eventManager.clearEventsQueue();\n    }\n  }\n\n  // Helper method to wait for initialization\n  private async waitForInitialization(): Promise<void> {\n    if (this.initializationState === InitializationState.INITIALIZED) {\n      return;\n    }\n\n    if (this.initializationState === InitializationState.FAILED) {\n      throw new Error('[TraceLog] Initialization failed, cannot perform operation');\n    }\n\n    if (this.initializationState === InitializationState.INITIALIZING && this.initializationPromise) {\n      try {\n        await this.initializationPromise;\n      } catch {\n        throw new Error('[TraceLog] Initialization failed during wait');\n      }\n    }\n\n    if (this.initializationState === InitializationState.UNINITIALIZED) {\n      throw new Error('[TraceLog] Not initialized');\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/nachocortesgarcia/Desktop/code/_personal/tracelog/tracelog-script/src/types.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":192,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":192,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4743,4746],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4743,4746],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":199,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":199,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4953,4956],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4953,4956],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":211,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":211,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5271,5274],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5271,5274],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export enum EventType {\n  PAGE_VIEW = 'page_view',\n  CLICK = 'click',\n  SCROLL = 'scroll',\n  SESSION_START = 'session_start',\n  SESSION_END = 'session_end',\n  CUSTOM = 'custom',\n}\n\nexport enum ScrollDirection {\n  UP = 'up',\n  DOWN = 'down',\n}\n\nexport type MetadataType = string | number | boolean | string[];\n\n// Type guards\nexport function isMetadataType(value: unknown): value is MetadataType {\n  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n    return true;\n  }\n\n  if (Array.isArray(value)) {\n    return value.every((item) => typeof item === 'string');\n  }\n\n  return false;\n}\n\nexport function isValidMetadataRecord(value: unknown): value is Record<string, MetadataType> {\n  if (typeof value !== 'object' || value === null) {\n    return false;\n  }\n\n  const object = value as Record<string, unknown>;\n  return Object.values(object).every((value_) => isMetadataType(value_));\n}\n\nexport function isEventType(value: unknown): value is EventType {\n  return typeof value === 'string' && Object.values(EventType).includes(value as EventType);\n}\n\nexport function isScrollDirection(value: unknown): value is ScrollDirection {\n  return typeof value === 'string' && Object.values(ScrollDirection).includes(value as ScrollDirection);\n}\n\n// Branded types for better type safety\nexport type UserId = string & { readonly __brand: 'UserId' };\nexport type SessionId = string & { readonly __brand: 'SessionId' };\nexport type Timestamp = number & { readonly __brand: 'Timestamp' };\nexport type URL = string & { readonly __brand: 'URL' };\n\n// Type constructors\nexport function createUserId(id: string): UserId {\n  if (typeof id !== 'string' || id.length === 0) {\n    throw new Error('Invalid user ID');\n  }\n  return id as UserId;\n}\n\nexport function createSessionId(id: string): SessionId {\n  if (typeof id !== 'string' || id.length === 0) {\n    throw new Error('Invalid session ID');\n  }\n  return id as SessionId;\n}\n\nexport function createTimestamp(timestamp?: number): Timestamp {\n  const ts = timestamp ?? Date.now();\n  if (typeof ts !== 'number' || ts <= 0) {\n    throw new Error('Invalid timestamp');\n  }\n  return ts as Timestamp;\n}\n\nexport function createURL(url: string): URL {\n  if (typeof url !== 'string' || url.length === 0) {\n    throw new Error('Invalid URL');\n  }\n\n  try {\n    new URL(url);\n  } catch {\n    throw new Error('Invalid URL format');\n  }\n\n  return url as URL;\n}\n\nexport interface TracelogEventScrollData {\n  depth: number;\n  direction: ScrollDirection;\n}\n\nexport interface TracelogEventClickData {\n  x: number;\n  y: number;\n  relativeX: number;\n  relativeY: number;\n  elementId?: string;\n  elementClass?: string;\n  elementTag?: string;\n  elementText?: string;\n  elementHref?: string;\n  elementTitle?: string;\n  elementAlt?: string;\n  elementRole?: string;\n  elementAriaLabel?: string;\n  elementDataAttributes?: Record<string, string>;\n}\n\nexport interface TracelogEventCustomData {\n  name: string;\n  metadata?: Record<string, MetadataType>;\n}\n\nexport interface TracelogEventUtm {\n  source?: string;\n  medium?: string;\n  campaign?: string;\n  term?: string;\n  content?: string;\n}\n\nexport interface TracelogEventPageView {\n  referrer?: string;\n  title?: string;\n  pathname?: string;\n  search?: string;\n  hash?: string;\n}\n\nexport interface TracelogEventHandler {\n  evType: EventType;\n  url?: string;\n  fromUrl?: string;\n  referrer?: string;\n  utm?: TracelogEventUtm;\n  scrollData?: TracelogEventScrollData;\n  clickData?: TracelogEventClickData;\n  customEvent?: TracelogEventCustomData;\n  pageView?: TracelogEventPageView;\n  trigger?: string;\n}\n\nexport interface TracelogEvent {\n  type: EventType;\n  page_url: string;\n  timestamp: Timestamp;\n  referrer?: string;\n  from_page_url?: string;\n  scroll_data?: TracelogEventScrollData;\n  click_data?: TracelogEventClickData;\n  custom_event?: TracelogEventCustomData;\n  page_view?: TracelogEventPageView;\n  utm?: TracelogEventUtm;\n  tags?: string[];\n  excluded_route?: boolean;\n}\n\n// Type guard for TracelogEvent\nexport function isTracelogEvent(value: unknown): value is TracelogEvent {\n  if (typeof value !== 'object' || value === null) {\n    return false;\n  }\n\n  const event = value as Record<string, unknown>;\n\n  // Required fields\n  if (!isEventType(event.type)) {\n    return false;\n  }\n\n  if (typeof event.page_url !== 'string') {\n    return false;\n  }\n\n  if (typeof event.timestamp !== 'number') {\n    return false;\n  }\n\n  // Optional fields validation\n  if (event.referrer !== undefined && typeof event.referrer !== 'string') {\n    return false;\n  }\n\n  if (event.from_page_url !== undefined && typeof event.from_page_url !== 'string') {\n    return false;\n  }\n\n  if (event.scroll_data !== undefined) {\n    const scrollData = event.scroll_data as any;\n    if (typeof scrollData.depth !== 'number' || !isScrollDirection(scrollData.direction)) {\n      return false;\n    }\n  }\n\n  if (event.click_data !== undefined) {\n    const clickData = event.click_data as any;\n    if (\n      typeof clickData.x !== 'number' ||\n      typeof clickData.y !== 'number' ||\n      typeof clickData.relativeX !== 'number' ||\n      typeof clickData.relativeY !== 'number'\n    ) {\n      return false;\n    }\n  }\n\n  if (event.custom_event !== undefined) {\n    const customEvent = event.custom_event as any;\n    if (typeof customEvent.name !== 'string') {\n      return false;\n    }\n    if (customEvent.metadata !== undefined && !isValidMetadataRecord(customEvent.metadata)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport interface TracelogQueue {\n  user_id: string;\n  session_id: string;\n  device: string;\n  events: TracelogEvent[];\n  global_metadata?: Record<string, MetadataType>;\n}\n\n// Type guard for TracelogQueue\nexport function isTracelogQueue(value: unknown): value is TracelogQueue {\n  if (typeof value !== 'object' || value === null) {\n    return false;\n  }\n\n  const queue = value as Record<string, unknown>;\n\n  if (typeof queue.user_id !== 'string' || typeof queue.session_id !== 'string' || typeof queue.device !== 'string') {\n    return false;\n  }\n\n  if (!Array.isArray(queue.events)) {\n    return false;\n  }\n\n  if (!queue.events.every((event) => isTracelogEvent(event))) {\n    return false;\n  }\n\n  if (queue.global_metadata !== undefined && !isValidMetadataRecord(queue.global_metadata)) {\n    return false;\n  }\n\n  return true;\n}\n\nexport interface TracelogTag {\n  id: string;\n  name: string;\n  description?: string;\n  triggerType: EventType;\n  logicalOperator: 'AND' | 'OR';\n  conditions: TracelogTagCondition[];\n  isActive: boolean;\n}\n\nexport interface TracelogTagCondition {\n  type: 'url_matches' | 'element_matches' | 'device_type' | 'utm_source' | 'utm_medium' | 'utm_campaign';\n  operator: 'equals' | 'contains' | 'starts_with' | 'ends_with' | 'regex' | 'not_equals' | 'not_contains';\n  value: string;\n  caseSensitive?: boolean;\n}\n\nexport interface TracelogApiConfig {\n  qaMode: boolean;\n  samplingRate: number;\n  tags: TracelogTag[];\n  excludedUrlPaths: string[];\n}\n\nexport interface TracelogAppConfig {\n  sessionTimeout?: number;\n  globalMetadata?: Record<string, MetadataType>;\n  scrollContainerSelectors?: string | string[];\n}\n\nexport interface TracelogConfig extends TracelogApiConfig, TracelogAppConfig {}\n\nexport interface TracelogAdminError {\n  message: string;\n  timestamp: number;\n  userAgent: string;\n  url: string;\n  api_key?: string;\n  stack?: string;\n  severity?: 'low' | 'medium' | 'high';\n  context?: string;\n}\n\n// Runtime validation utilities\nexport class ValidationError extends Error {\n  constructor(\n    message: string,\n    public readonly field: string,\n    public readonly value: unknown,\n  ) {\n    super(message);\n    this.name = 'ValidationError';\n  }\n}\n\nexport function validateRequired<T>(value: T, fieldName: string): NonNullable<T> {\n  if (value === null || value === undefined) {\n    throw new ValidationError(`${fieldName} is required`, fieldName, value);\n  }\n  return value as NonNullable<T>;\n}\n\nexport function validateString(value: unknown, fieldName: string): string {\n  if (typeof value !== 'string') {\n    throw new ValidationError(`${fieldName} must be a string`, fieldName, value);\n  }\n  return value;\n}\n\nexport function validateNumber(value: unknown, fieldName: string): number {\n  if (typeof value !== 'number' || !Number.isFinite(value)) {\n    throw new ValidationError(`${fieldName} must be a valid number`, fieldName, value);\n  }\n  return value;\n}\n\nexport function validateBoolean(value: unknown, fieldName: string): boolean {\n  if (typeof value !== 'boolean') {\n    throw new ValidationError(`${fieldName} must be a boolean`, fieldName, value);\n  }\n  return value;\n}\n\nexport function validateArray<T>(value: unknown, fieldName: string, itemValidator?: (item: unknown) => T): T[] {\n  if (!Array.isArray(value)) {\n    throw new ValidationError(`${fieldName} must be an array`, fieldName, value);\n  }\n\n  if (itemValidator) {\n    return value.map((item, index) => {\n      try {\n        return itemValidator(item);\n      } catch {\n        throw new ValidationError(`${fieldName}[${index}] is invalid`, `${fieldName}[${index}]`, item);\n      }\n    });\n  }\n\n  return value as T[];\n}\n\nexport function validateObject<T>(value: unknown, fieldName: string, validator: (object: unknown) => T): T {\n  if (typeof value !== 'object' || value === null) {\n    throw new ValidationError(`${fieldName} must be an object`, fieldName, value);\n  }\n\n  return validator(value);\n}\n\n// Safe type conversion utilities\nexport function safeParseInt(value: unknown, defaultValue = 0): number {\n  if (typeof value === 'number') {\n    return Math.floor(value);\n  }\n\n  if (typeof value === 'string') {\n    const parsed = Number.parseInt(value, 10);\n    return Number.isNaN(parsed) ? defaultValue : parsed;\n  }\n\n  return defaultValue;\n}\n\nexport function safeParseFloat(value: unknown, defaultValue = 0): number {\n  if (typeof value === 'number') {\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    const parsed = Number.parseFloat(value);\n    return Number.isNaN(parsed) ? defaultValue : parsed;\n  }\n\n  return defaultValue;\n}\n\nexport function safeParseBoolean(value: unknown, defaultValue = false): boolean {\n  if (typeof value === 'boolean') {\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    const lower = value.toLowerCase();\n    return lower === 'true' || lower === '1' || lower === 'yes';\n  }\n\n  if (typeof value === 'number') {\n    return value !== 0;\n  }\n\n  return defaultValue;\n}\n\nexport function safeParseArray<T>(value: unknown, defaultValue: T[] = []): T[] {\n  if (Array.isArray(value)) {\n    return value;\n  }\n\n  return defaultValue;\n}\n\nexport function safeParseObject<T extends Record<string, unknown>>(value: unknown, defaultValue: T): T {\n  if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n    return value as T;\n  }\n\n  return defaultValue;\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/nachocortesgarcia/Desktop/code/_personal/tracelog/tracelog-script/src/utils/device-detector.ts","messages":[{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":4,"column":49,"nodeType":"Literal","messageId":"error","endLine":4,"endColumn":53,"suggestions":[{"messageId":"remove","fix":{"range":[135,142],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[138,142],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":5,"column":43,"nodeType":"Literal","messageId":"error","endLine":5,"endColumn":47,"suggestions":[{"messageId":"remove","fix":{"range":[183,190],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[186,190],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DeviceType } from '../constants';\n\n// Cache media queries for better performance\nlet coarsePointerQuery: MediaQueryList | null = null;\nlet noHoverQuery: MediaQueryList | null = null;\n\nconst initMediaQueries = (): void => {\n  if (typeof window !== 'undefined' && !coarsePointerQuery) {\n    coarsePointerQuery = window.matchMedia('(pointer: coarse)');\n    noHoverQuery = window.matchMedia('(hover: none)');\n  }\n};\n\ninterface NavigatorWithUserAgentData extends Navigator {\n  userAgentData?: {\n    mobile: boolean;\n    platform?: string;\n  };\n}\n\nexport const getDeviceType = (): DeviceType => {\n  try {\n    const nav = navigator as NavigatorWithUserAgentData;\n\n    // Try modern User-Agent Client Hints API first\n    if (nav.userAgentData && typeof nav.userAgentData.mobile === 'boolean') {\n      if (nav.userAgentData.platform && /ipad|tablet/i.test(nav.userAgentData.platform)) {\n        return DeviceType.Tablet;\n      }\n      return nav.userAgentData.mobile ? DeviceType.Mobile : DeviceType.Desktop;\n    }\n\n    // Initialize media queries on first call\n    initMediaQueries();\n\n    const width = window.innerWidth;\n    const hasCoarsePointer = coarsePointerQuery?.matches ?? false;\n    const hasNoHover = noHoverQuery?.matches ?? false;\n    const hasTouchSupport = 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n    const ua = navigator.userAgent.toLowerCase();\n    const isMobileUA = /mobile|android|iphone|ipod|blackberry|iemobile|opera mini/.test(ua);\n    const isTabletUA = /tablet|ipad|android(?!.*mobile)/.test(ua);\n\n    // Mobile detection: small screen OR mobile UA with touch\n    if (width <= 767 || (isMobileUA && hasTouchSupport)) {\n      return DeviceType.Mobile;\n    }\n\n    // Tablet detection: medium screen OR tablet UA OR touch with coarse pointer and no hover\n    if ((width >= 768 && width <= 1024) || isTabletUA || (hasCoarsePointer && hasNoHover && hasTouchSupport)) {\n      return DeviceType.Tablet;\n    }\n\n    return DeviceType.Desktop;\n  } catch {\n    return DeviceType.Unknown;\n  }\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/nachocortesgarcia/Desktop/code/_personal/tracelog/tracelog-script/src/utils/event-check.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[326,329],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[326,329],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":92,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":92,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2243,2246],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2243,2246],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":94,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2338,2341],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2338,2341],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":176,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":176,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4706,4709],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4706,4709],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":177,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":177,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4784,4787],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4784,4787],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  MAX_CUSTOM_EVENT_NAME_LENGTH,\n  MAX_CUSTOM_EVENT_STRING_SIZE,\n  MAX_CUSTOM_EVENT_KEYS,\n  MAX_CUSTOM_EVENT_ARRAY_SIZE,\n} from '../constants';\nimport { sanitizeMetadata } from './sanitize';\n\n/**\n * Validates if an object contains only primitive fields\n */\nexport const isOnlyPrimitiveFields = (object: Record<string, any>): boolean => {\n  if (typeof object !== 'object' || object === null) {\n    return false;\n  }\n\n  for (const value of Object.values(object)) {\n    if (value === null || value === undefined) {\n      continue;\n    }\n\n    const type = typeof value;\n    if (type === 'string' || type === 'number' || type === 'boolean') {\n      continue;\n    }\n\n    if (Array.isArray(value)) {\n      // Check if array contains only strings\n      if (!value.every((item) => typeof item === 'string')) {\n        return false;\n      }\n      continue;\n    }\n\n    // Any other type is not allowed\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Validates event name with security checks\n */\nexport const isValidEventName = (eventName: string): { valid: boolean; error?: string } => {\n  if (typeof eventName !== 'string') {\n    return {\n      valid: false,\n      error: 'Event name must be a string',\n    };\n  }\n\n  if (eventName.length === 0) {\n    return {\n      valid: false,\n      error: 'Event name cannot be empty',\n    };\n  }\n\n  if (eventName.length > MAX_CUSTOM_EVENT_NAME_LENGTH) {\n    return {\n      valid: false,\n      error: `Event name is too long (max ${MAX_CUSTOM_EVENT_NAME_LENGTH} characters)`,\n    };\n  }\n\n  // Check for potentially dangerous characters\n  if (eventName.includes('<') || eventName.includes('>') || eventName.includes('&')) {\n    return {\n      valid: false,\n      error: 'Event name contains invalid characters',\n    };\n  }\n\n  // Check for JavaScript keywords and reserved words\n  const reservedWords = ['constructor', 'prototype', '__proto__', 'eval', 'function', 'var', 'let', 'const'];\n  if (reservedWords.includes(eventName.toLowerCase())) {\n    return {\n      valid: false,\n      error: 'Event name cannot be a reserved word',\n    };\n  }\n\n  return { valid: true };\n};\n\n/**\n * Validates metadata with enhanced security\n */\nexport const isValidMetadata = (\n  eventName: string,\n  metadata: Record<string, any>,\n  type?: string,\n): { valid: boolean; error?: string; sanitizedMetadata?: Record<string, any> } => {\n  const intro = type && type === 'sendCustomEvent' ? `${type} \"${eventName}\" metadata error` : `${eventName} metadata error`;\n\n  // Sanitize metadata first\n  const sanitizedMetadata = sanitizeMetadata(metadata);\n\n  if (!isOnlyPrimitiveFields(sanitizedMetadata)) {\n    return {\n      valid: false,\n      error: `${intro}: object has invalid types. Valid types are string, number, boolean or string arrays.`,\n    };\n  }\n\n  // Check for circular references and get size\n  let jsonString: string;\n  try {\n    jsonString = JSON.stringify(sanitizedMetadata);\n  } catch {\n    return {\n      valid: false,\n      error: `${intro}: object contains circular references or cannot be serialized.`,\n    };\n  }\n\n  // Use JSON string length for accurate size validation\n  if (jsonString.length > MAX_CUSTOM_EVENT_STRING_SIZE) {\n    return {\n      valid: false,\n      error: `${intro}: object is too large (max ${MAX_CUSTOM_EVENT_STRING_SIZE / 1024} KB).`,\n    };\n  }\n\n  // Check key count limit\n  const keyCount = Object.keys(sanitizedMetadata).length;\n  if (keyCount > MAX_CUSTOM_EVENT_KEYS) {\n    return {\n      valid: false,\n      error: `${intro}: object has too many keys (max ${MAX_CUSTOM_EVENT_KEYS} keys).`,\n    };\n  }\n\n  // Check array size limits and validate array contents\n  for (const [key, value] of Object.entries(sanitizedMetadata)) {\n    if (Array.isArray(value)) {\n      if (value.length > MAX_CUSTOM_EVENT_ARRAY_SIZE) {\n        return {\n          valid: false,\n          error: `${intro}: array property \"${key}\" is too large (max ${MAX_CUSTOM_EVENT_ARRAY_SIZE} items).`,\n        };\n      }\n\n      // Validate each array item\n      for (const item of value) {\n        if (typeof item === 'string' && item.length > 500) {\n          return {\n            valid: false,\n            error: `${intro}: array property \"${key}\" contains strings that are too long (max 500 characters).`,\n          };\n        }\n      }\n    }\n\n    // Validate individual string values\n    if (typeof value === 'string' && value.length > 1000) {\n      return {\n        valid: false,\n        error: `${intro}: property \"${key}\" is too long (max 1000 characters).`,\n      };\n    }\n  }\n\n  return {\n    valid: true,\n    sanitizedMetadata,\n  };\n};\n\n/**\n * Enhanced event validation with security checks\n */\nexport const isEventValid = (\n  eventName: string,\n  metadata?: Record<string, any>,\n): { valid: boolean; error?: string; sanitizedMetadata?: Record<string, any> } => {\n  // Validate event name first\n  const nameValidation = isValidEventName(eventName);\n  if (!nameValidation.valid) {\n    return nameValidation;\n  }\n\n  // If no metadata, validation passes\n  if (!metadata) {\n    return { valid: true };\n  }\n\n  // Validate metadata\n  return isValidMetadata(eventName, metadata, 'sendCustomEvent');\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/nachocortesgarcia/Desktop/code/_personal/tracelog/tracelog-script/src/utils/sanitize.ts","messages":[{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":55,"column":12,"nodeType":"Literal","messageId":"error","endLine":55,"endColumn":16,"suggestions":[{"messageId":"remove","fix":{"range":[1375,1379],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[1375,1379],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":59,"column":12,"nodeType":"Literal","messageId":"error","endLine":59,"endColumn":16,"suggestions":[{"messageId":"remove","fix":{"range":[1444,1448],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[1444,1448],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":104,"column":10,"nodeType":"Literal","messageId":"error","endLine":104,"endColumn":14,"suggestions":[{"messageId":"remove","fix":{"range":[2597,2601],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[2597,2601],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":126,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":126,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3071,3074],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3071,3074],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const ALLOWED_API_CONFIG_KEYS = ['tagsManager', 'samplingRate', 'qaMode', 'excludedUrlPaths'] as const;\n\n// Security constants\nconst MAX_STRING_LENGTH = 1000;\nconst MAX_ARRAY_LENGTH = 100;\nconst MAX_OBJECT_DEPTH = 3;\n\n// XSS prevention patterns\nconst XSS_PATTERNS = [\n  /<script[^>]*>.*?<\\/script>/gi,\n  /javascript:/gi,\n  /on\\w+\\s*=/gi,\n  /<iframe[^>]*>.*?<\\/iframe>/gi,\n  /data:text\\/html/gi,\n  /vbscript:/gi,\n];\n\n/**\n * Sanitizes a string value to prevent XSS attacks\n */\nexport const sanitizeString = (value: string): string => {\n  if (typeof value !== 'string') {\n    return '';\n  }\n\n  // Limit string length\n  if (value.length > MAX_STRING_LENGTH) {\n    value = value.slice(0, Math.max(0, MAX_STRING_LENGTH));\n  }\n\n  // Remove potential XSS patterns\n  let sanitized = value;\n  for (const pattern of XSS_PATTERNS) {\n    sanitized = sanitized.replace(pattern, '');\n  }\n\n  // Basic HTML entity encoding for critical characters\n  sanitized = sanitized\n    .replaceAll('&', '&amp;')\n    .replaceAll('<', '&lt;')\n    .replaceAll('>', '&gt;')\n    .replaceAll('\"', '&quot;')\n    .replaceAll('\\'', '&#x27;')\n    .replaceAll('/', '&#x2F;');\n\n  return sanitized.trim();\n};\n\n/**\n * Sanitizes any value recursively with depth protection\n */\nconst sanitizeValue = (value: unknown, depth = 0): unknown => {\n  // Prevent infinite recursion\n  if (depth > MAX_OBJECT_DEPTH) {\n    return null;\n  }\n\n  if (value === null || value === undefined) {\n    return null;\n  }\n\n  if (typeof value === 'string') {\n    return sanitizeString(value);\n  }\n\n  if (typeof value === 'number') {\n    // Validate number ranges\n    if (!Number.isFinite(value) || value < -Number.MAX_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n      return 0;\n    }\n    return value;\n  }\n\n  if (typeof value === 'boolean') {\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    // Limit array length\n    const limitedArray = value.slice(0, MAX_ARRAY_LENGTH);\n    return limitedArray.map((item) => sanitizeValue(item, depth + 1)).filter((item) => item !== null);\n  }\n\n  if (typeof value === 'object') {\n    const sanitizedObject: Record<string, unknown> = {};\n    const entries = Object.entries(value);\n\n    // Limit object properties\n    const limitedEntries = entries.slice(0, 20);\n\n    for (const [key, value_] of limitedEntries) {\n      const sanitizedKey = sanitizeString(key);\n      if (sanitizedKey) {\n        const sanitizedValue = sanitizeValue(value_, depth + 1);\n        if (sanitizedValue !== null) {\n          sanitizedObject[sanitizedKey] = sanitizedValue;\n        }\n      }\n    }\n\n    return sanitizedObject;\n  }\n\n  return null;\n};\n\n/**\n * Sanitizes API configuration data with strict validation\n */\nexport const sanitizeApiConfig = (\n  data: unknown,\n): Partial<{\n  tagsManager: unknown;\n  samplingRate: unknown;\n  qaMode: unknown;\n  excludedUrlPaths: unknown;\n}> => {\n  const safeData: Record<string, unknown> = {};\n\n  if (typeof data !== 'object' || data === null) {\n    return safeData;\n  }\n\n  try {\n    for (const key of Object.keys(data)) {\n      if (ALLOWED_API_CONFIG_KEYS.includes(key as any)) {\n        const value = (data as Record<string, unknown>)[key];\n        const sanitizedValue = sanitizeValue(value);\n\n        if (sanitizedValue !== null) {\n          safeData[key] = sanitizedValue;\n        }\n      }\n    }\n  } catch (error) {\n    // Return empty object if sanitization fails\n    console.warn('[TraceLog] API config sanitization failed:', error);\n    return {};\n  }\n\n  return safeData;\n};\n\n/**\n * Sanitizes user metadata for custom events\n */\nexport const sanitizeMetadata = (metadata: unknown): Record<string, unknown> => {\n  if (typeof metadata !== 'object' || metadata === null) {\n    return {};\n  }\n\n  try {\n    const sanitized = sanitizeValue(metadata);\n    return typeof sanitized === 'object' && sanitized !== null ? (sanitized as Record<string, unknown>) : {};\n  } catch (error) {\n    console.warn('[TraceLog] Metadata sanitization failed:', error);\n    return {};\n  }\n};\n\n/**\n * Sanitizes URL strings for tracking\n */\nexport const sanitizeUrl = (url: string): string => {\n  if (typeof url !== 'string') {\n    return '';\n  }\n\n  try {\n    // Basic URL validation\n    const urlObject = new URL(url);\n\n    // Only allow http/https protocols\n    if (!['http:', 'https:'].includes(urlObject.protocol)) {\n      return '';\n    }\n\n    // Sanitize the URL string\n    return sanitizeString(urlObject.href);\n  } catch {\n    // If URL parsing fails, sanitize as string\n    return sanitizeString(url);\n  }\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/nachocortesgarcia/Desktop/code/_personal/tracelog/tracelog-script/src/utils/validate-url.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]
